{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GIGA infrastructure mapping toolkit Background The Giga Inframap Toolkit is a comprehensive suite of tools designed for the analysis and visualization of telecommunication infrastructure data. This toolkit offers a robust set of modules including data processing, mapping, visibility, fiber path and cost analyses - each engineered to address specific aspects of infrastructure analysis and planning. This documentation serves as a guide to the Giga Inframap Toolkit, providing detailed insights into its functionality and application.","title":"Home"},{"location":"#giga-infrastructure-mapping-toolkit","text":"","title":"GIGA infrastructure mapping toolkit"},{"location":"#background","text":"The Giga Inframap Toolkit is a comprehensive suite of tools designed for the analysis and visualization of telecommunication infrastructure data. This toolkit offers a robust set of modules including data processing, mapping, visibility, fiber path and cost analyses - each engineered to address specific aspects of infrastructure analysis and planning. This documentation serves as a guide to the Giga Inframap Toolkit, providing detailed insights into its functionality and application.","title":"Background"},{"location":"assignment/","text":"Technology Assignment","title":"Technology Assignment"},{"location":"assignment/#technology-assignment","text":"","title":"Technology Assignment"},{"location":"costmodel/","text":"Costs Overview The CostModel class calculates deployment and operational costs for telecommunications infrastructure. It provides cost analysis for multiple technology options (fiber, cellular, point-to-point, satellite, and electricity) to support infrastructure planning decisions, computing capital expenditures (CAPEX), operational expenditures (OPEX), and operator revenue projections for each technology option. Key features: Multi-technology cost analysis (fiber, cellular, point-to-point, satellite, electricity) Capital expenditure (CAPEX) calculations including equipment and installation costs Operational expenditure (OPEX) calculations including maintenance and traffic fees Operator revenue projections based on throughput requirements Cost of ownership analysis over multiple time periods Per-POI cost breakdowns for detailed planning Class Parameters Parameter Type Default Description primary_tech_params pd.DataFrame Required DataFrame containing technology parameters with columns 'Variable name' and 'Value'. Must include all parameters defined in get_required_keys() logger logging.Logger None Logger instance for logging messages expansion_factor float 1.1 Factor to increase the amount of fiber line required by 10% (or other amount) Example of primary_tech_params input Technology Parameter Variable name Value Measurement unit fiber On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_fiber 500 USD per school\u200b fiber Fiber optical cable line\u200b construction cost (materials, equipment, labor) focl_constr_cost_fiber 8000 USD per km\u200b fiber Hardware refresh after reinv_period_fiber 5 Years fiber Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_fiber 0.1 USD per year\u200b (as a fraction of hardware CapEx\u200b) fiber Annual transit bandwidth cost for 1 Mbps of dedicated internet access channel over a fiber optic cable line an_traffic_fees_one_mbps_fiber 12 USD per Mbps per year fiber Annual access bandwidth cost for 1 Mbps of dedicated internet access channel over a fiber optic cable line an_isp_fees_one_mbps_fiber 31.8 USD per Mbps per year fiber Time required to install fiber infrastructure invest_time_fiber 0 Years p2area On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_p2area 80 USD per school\u200b p2area Reinvest into hardware after reinv_period_p2area 3 Years p2area Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_p2area 0.1 USD per year\u200b (as a fraction of hardware CapEx\u200b) p2area Annual Traffic fee for 1 Mbps of dedicated internet access channel over cellular network an_traffic_fees_one_mbps_p2area 12 USD per Mbps per year p2area Annual ISP fee for 1 Mbps of dedicated internet access channel over cellular network an_isp_fees_one_mbps_p2area 24 USD per Mbps per year p2area Time required to install cellular infrastructure invest_time_p2area 0 Years p2p On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_p2p 500 USD per school\u200b p2p Microwave point-to-point access link installation and comissioning cost (materials, equipment, labor) access_link_setup_p2p 831.59 USD per hop\u200b p2p Number of microwave point-to-point backhaul links backhaul_link_num_p2p 0 Links p2p Microwave point-to-point backhaul link installation and comissioning cost (materials, equipment, labor) backhaul_link_setup_p2p 2825.07 USD per hop\u200b p2p Number of retransmission telecommunication towers retr_tower_num_p2p 0 Towers p2p Retransmission telecommunication tower installation cost retr_tower_inst_p2p 13000 USD per tower p2p Bandwidth per access link access_link_bandwidth_p2p 10 MHz p2p Bandwidth per backhaul link backhaul_link_bandwidth_p2p 20 MHz p2p One time license fee for 1MHz one_time_license_fee_1mhz_p2p 500 USD per MHz p2p Reinvest into hardware after reinv_period_p2p 5 Years p2p Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_p2p 0.004 USD per year\u200b (as a fraction of hardware CapEx\u200b) p2p Annual recurring license fee for 1MHz an_license_fee_1mhz_p2p 100 USD per MHz per year p2p Annual Traffic fee for 1 Mbps of dedicated internet access channel over a P2P microwave link an_traffic_fees_one_mbps_p2p 12 USD per Mbps per year p2p Annual ISP fee for 1 Mbps of dedicated internet access channel over a P2P microwave link an_isp_fees_one_mbps_p2p 24 USD per Mbps per year p2p Time required to install P2P infrastructure invest_time_p2p 0 Years satellite On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_sat 3000 USD per school\u200b satellite Reinvest into hardware after reinv_period_sat 5 Years satellite Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_sat 0.04 USD per year\u200b (as a fraction of hardware CapEx\u200b) satellite Annual Traffic fee for 1 Mbps of dedicated internet access channel over satellite channel an_traffic_fees_one_mbps_sat 12 USD per Mbps per year satellite Annual ISP fee for 1 Mbps of dedicated internet access channel over satellite channel an_isp_fees_one_mbps_sat 24 USD per Mbps per year satellite Time required to install satellite infrastructure invest_time_sat 0 Years Electricity On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_electricity 0 USD per school\u200b Electricity Reinvest into hardware after reinv_period_electricity 1 Years Electricity Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_electricity 0 USD per year\u200b (as a fraction of hardware CapEx\u200b) Finance Interest rate interest_rate 0.02 Percentage Overall Project planning period pp 10 Years Class Attributes Attribute Type Description primary_tech_params pd.DataFrame DataFrame containing technology parameters expansion_factor float Factor for expanding fiber optic cable length in calculations logger logging.Logger Logger instance for logging messages Methods Method Return Type Description get_required_keys() list Returns list of required parameter names for cost calculations validate_inputs(primary_tech_params) None Validates the input parameters compute_fiber_costs(poi_num, ch_throughput, focl_length_fiber, pp) pd.DataFrame Calculates fiber network deployment costs compute_p2area_costs(poi_num, ch_throughput, pp) pd.DataFrame Calculates cellular (point-to-area) network deployment costs compute_p2p_costs(poi_num, ch_throughput, pp) pd.DataFrame Calculates point-to-point network deployment costs compute_satellite_costs(poi_num, ch_throughput, pp) pd.DataFrame Calculates satellite network deployment costs compute_electricity_costs(poi_num, pp) pd.DataFrame Calculates electricity costs perform_analysis(poi_data) pd.DataFrame Computes POI-level costs across all technology options for a given dataset The cost calculation methods ( compute_fiber_costs , compute_p2area_costs , compute_p2p_costs , compute_satellite_costs , compute_electricity_costs ) each produce a pd.DataFrame output with the following keys: technology : The technology type being analyzed (in this example \"satellite\", but could also be fiber, p2area, p2p, or electricity) number_poi : Number of points of interest (POIs) included in this calculation ch_throughput : Channel throughput in Mbps (megabits per second) pp : Planning period in years - the time horizon for the analysis pp_profit : Total profit over the entire planning period - calculated as revenue minus cost of ownership pp_profit_per_poi : Average profit per POI over the entire planning period pp_revenue : Total revenue generated over the entire planning period pp_revenue_per_poi : Average revenue per POI over the entire planning period pp_coo : Total cost of ownership over the entire planning period (includes both CAPEX and OPEX) pp_coo_per_poi : Average cost of ownership per POI over the entire planning period init_capex : Initial capital expenditure - the upfront investment required to deploy the technology annual_revenue : Average annual revenue (calculated as total planning period revenue divided by number of years) annual_revenue_per_poi : Average annual revenue per POI annual_cost : Average annual cost (includes CAPEX and OPEX) annual_cost_per_poi : Average annual cost per POI - a key metric for comparing the cost-effectiveness of different technologies The method perform_analysis(poi_data) should be provided with an input DataFrame with the following columns: poi_id : unique identifier (UUID) total_mbps : total throughput in Mbps for each POI (estimated using the Demand module of the toolkit) upstream_node_distance : distance to the nearest transmission node (or connected POI) according the the FiberPath solution. This is the additional length of fiber required to connect the POI to the fiber network. has_electricity : whether the POI is already electrified or not ( bool ). poi_id total_mbps upstream_node_distance has_electricity 09b90515-0ecc-4992-9d39-ae208e1c1fea 415 0 True 0c16c2e8-db92-411b-a6f7-535fb1810e34 1210 0 True 1205e5ef-5d91-47b7-8fc0-11ef019263e5 7640 1682.919 True 1534adf8-b45c-443b-8e1d-87a504e6dc64 865 1887.719 True 192c1704-9e7e-4b7a-8ba7-0eed5ae771ad 79410 906.343 True The output is structured as a multi-indexed pandas DataFrame with the following index levels: poi_id : Unique identifier for each point of interest pp : Planning period (year number from 1 to the total project planning period) technology : Technology type (fiber, p2area, p2p, satellite, electricity) metric : Cost metric (e.g., pp_profit, annual_cost_per_poi, pp_revenue, etc.) The value column contains the actual numerical results for each combination of indices. Summary of cost models Fiber Table. Fiber cost model parameters. Technology Parameter Variable name Value Measurement unit fiber On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_fiber 500 USD per school\u200b fiber Fiber optical cable line\u200b construction cost (materials, equipment, labor) focl_constr_cost_fiber 8000 USD per km\u200b fiber Hardware refresh after reinv_period_fiber 5 Years fiber Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_fiber 0.1 USD per year\u200b (as a fraction of hardware CapEx\u200b) fiber Annual transit bandwidth cost for 1 Mbps of dedicated internet access channel over a fiber optic cable line an_traffic_fees_one_mbps_fiber 12 USD per Mbps per year fiber Annual access bandwidth cost for 1 Mbps of dedicated internet access channel over a fiber optic cable line an_isp_fees_one_mbps_fiber 31.8 USD per Mbps per year Figure. Fiber cost model. Cellular Table. Cellular cost model parameters. Technology Parameter Variable name Value Measurement unit p2area On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_p2area 80 USD per school\u200b p2area Reinvest into hardware after reinv_period_p2area 3 Years p2area Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_p2area 0.1 USD per year\u200b (as a fraction of hardware CapEx\u200b) p2area Annual Traffic fee for 1 Mbps of dedicated internet access channel over cellular network an_traffic_fees_one_mbps_p2area 12 USD per Mbps per year p2area Annual ISP fee for 1 Mbps of dedicated internet access channel over cellular network an_isp_fees_one_mbps_p2area 24 USD per Mbps per year p2area Time required to install cellular infrastructure invest_time_p2area 0 Years Figure. Cellular cost model. Point-to-point microwave Table. Point-to-point microwave cost model parameters. Technology Parameter Variable name Value Measurement unit p2p On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_p2p 500 USD per school\u200b p2p Microwave point-to-point access link installation and comissioning cost (materials, equipment, labor) access_link_setup_p2p 831.59 USD per hop\u200b p2p Number of microwave point-to-point backhaul links backhaul_link_num_p2p 0 Links p2p Microwave point-to-point backhaul link installation and comissioning cost (materials, equipment, labor) backhaul_link_setup_p2p 2825.07 USD per hop\u200b p2p Number of retransmission telecommunication towers retr_tower_num_p2p 0 Towers p2p Retransmission telecommunication tower installation cost retr_tower_inst_p2p 13000 USD per tower p2p Bandwidth per access link access_link_bandwidth_p2p 10 MHz p2p Bandwidth per backhaul link backhaul_link_bandwidth_p2p 20 MHz p2p One time license fee for 1MHz one_time_license_fee_1mhz_p2p 500 USD per MHz p2p Reinvest into hardware after reinv_period_p2p 5 Years p2p Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_p2p 0.004 USD per year\u200b (as a fraction of hardware CapEx\u200b) p2p Annual recurring license fee for 1MHz an_license_fee_1mhz_p2p 100 USD per MHz per year p2p Annual Traffic fee for 1 Mbps of dedicated internet access channel over a P2P microwave link an_traffic_fees_one_mbps_p2p 12 USD per Mbps per year p2p Annual ISP fee for 1 Mbps of dedicated internet access channel over a P2P microwave link an_isp_fees_one_mbps_p2p 24 USD per Mbps per year p2p Time required to install P2P infrastructure invest_time_p2p 0 Years Figure. Point-to-point microwave cost model. Satellite Table. Satellite cost model parameters. Technology Parameter Variable name Value Measurement unit satellite On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_sat 3000 USD per school\u200b satellite Reinvest into hardware after reinv_period_sat 5 Years satellite Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_sat 0.04 USD per year\u200b (as a fraction of hardware CapEx\u200b) satellite Annual Traffic fee for 1 Mbps of dedicated internet access channel over satellite channel an_traffic_fees_one_mbps_sat 12 USD per Mbps per year satellite Annual ISP fee for 1 Mbps of dedicated internet access channel over satellite channel an_isp_fees_one_mbps_sat 24 USD per Mbps per year Figure. Satellite cost model. Example import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.costmodel.costs import CostModel # 1. Set up your data collections # Points of Interest poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_df = poi_df[[\"poi_id\", \"has_electricity\"]] # Add columns 'total_mbps', 'upstream_node_distance' with random values poi_df['total_mbps'] = np.random.randint(10, 100, size=len(poi_df)) poi_df['upstream_node_distance'] = np.random.uniform(100, 10000, size=len(poi_df)).round(3) # Microeconomic inputs (e.g. cost per km of fiber) cost_inputs_df = pd.read_csv(\"input/cost_inputs.csv\") cost_inputs_df.head() # Variable name Value # 0 hw_setup_cost_fiber 500.0 # 1 focl_constr_cost_fiber 8000.0 # 2 reinv_period_fiber 5.0 # 3 an_hw_maint_and_repl_fiber 0.1 # 4 an_traffic_fees_one_mbps_fiber 12.0 # 2. Create a FiberPath analysis instance costmodel = CostModel(cost_inputs_df, logger=None) # 3. Run the analysis all_costs = costmodel.perform_analysis(poi_df) all_costs.head() # value # poi_id pp technology metric # 09b90515-0ecc-4992-9d39-ae208e1c1fea 1 fiber pp_profit 4430.0 # 0c16c2e8-db92-411b-a6f7-535fb1810e34 1 fiber pp_profit 13970.0 # 1205e5ef-5d91-47b7-8fc0-11ef019263e5 1 fiber pp_profit 74839.3 # 1534adf8-b45c-443b-8e1d-87a504e6dc64 1 fiber pp_profit -8443.1 # 192c1704-9e7e-4b7a-8ba7-0eed5ae771ad 1 fiber pp_profit 943596.6","title":"Cost"},{"location":"costmodel/#costs","text":"","title":"Costs"},{"location":"costmodel/#overview","text":"The CostModel class calculates deployment and operational costs for telecommunications infrastructure. It provides cost analysis for multiple technology options (fiber, cellular, point-to-point, satellite, and electricity) to support infrastructure planning decisions, computing capital expenditures (CAPEX), operational expenditures (OPEX), and operator revenue projections for each technology option. Key features: Multi-technology cost analysis (fiber, cellular, point-to-point, satellite, electricity) Capital expenditure (CAPEX) calculations including equipment and installation costs Operational expenditure (OPEX) calculations including maintenance and traffic fees Operator revenue projections based on throughput requirements Cost of ownership analysis over multiple time periods Per-POI cost breakdowns for detailed planning","title":"Overview"},{"location":"costmodel/#class-parameters","text":"Parameter Type Default Description primary_tech_params pd.DataFrame Required DataFrame containing technology parameters with columns 'Variable name' and 'Value'. Must include all parameters defined in get_required_keys() logger logging.Logger None Logger instance for logging messages expansion_factor float 1.1 Factor to increase the amount of fiber line required by 10% (or other amount) Example of primary_tech_params input Technology Parameter Variable name Value Measurement unit fiber On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_fiber 500 USD per school\u200b fiber Fiber optical cable line\u200b construction cost (materials, equipment, labor) focl_constr_cost_fiber 8000 USD per km\u200b fiber Hardware refresh after reinv_period_fiber 5 Years fiber Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_fiber 0.1 USD per year\u200b (as a fraction of hardware CapEx\u200b) fiber Annual transit bandwidth cost for 1 Mbps of dedicated internet access channel over a fiber optic cable line an_traffic_fees_one_mbps_fiber 12 USD per Mbps per year fiber Annual access bandwidth cost for 1 Mbps of dedicated internet access channel over a fiber optic cable line an_isp_fees_one_mbps_fiber 31.8 USD per Mbps per year fiber Time required to install fiber infrastructure invest_time_fiber 0 Years p2area On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_p2area 80 USD per school\u200b p2area Reinvest into hardware after reinv_period_p2area 3 Years p2area Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_p2area 0.1 USD per year\u200b (as a fraction of hardware CapEx\u200b) p2area Annual Traffic fee for 1 Mbps of dedicated internet access channel over cellular network an_traffic_fees_one_mbps_p2area 12 USD per Mbps per year p2area Annual ISP fee for 1 Mbps of dedicated internet access channel over cellular network an_isp_fees_one_mbps_p2area 24 USD per Mbps per year p2area Time required to install cellular infrastructure invest_time_p2area 0 Years p2p On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_p2p 500 USD per school\u200b p2p Microwave point-to-point access link installation and comissioning cost (materials, equipment, labor) access_link_setup_p2p 831.59 USD per hop\u200b p2p Number of microwave point-to-point backhaul links backhaul_link_num_p2p 0 Links p2p Microwave point-to-point backhaul link installation and comissioning cost (materials, equipment, labor) backhaul_link_setup_p2p 2825.07 USD per hop\u200b p2p Number of retransmission telecommunication towers retr_tower_num_p2p 0 Towers p2p Retransmission telecommunication tower installation cost retr_tower_inst_p2p 13000 USD per tower p2p Bandwidth per access link access_link_bandwidth_p2p 10 MHz p2p Bandwidth per backhaul link backhaul_link_bandwidth_p2p 20 MHz p2p One time license fee for 1MHz one_time_license_fee_1mhz_p2p 500 USD per MHz p2p Reinvest into hardware after reinv_period_p2p 5 Years p2p Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_p2p 0.004 USD per year\u200b (as a fraction of hardware CapEx\u200b) p2p Annual recurring license fee for 1MHz an_license_fee_1mhz_p2p 100 USD per MHz per year p2p Annual Traffic fee for 1 Mbps of dedicated internet access channel over a P2P microwave link an_traffic_fees_one_mbps_p2p 12 USD per Mbps per year p2p Annual ISP fee for 1 Mbps of dedicated internet access channel over a P2P microwave link an_isp_fees_one_mbps_p2p 24 USD per Mbps per year p2p Time required to install P2P infrastructure invest_time_p2p 0 Years satellite On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_sat 3000 USD per school\u200b satellite Reinvest into hardware after reinv_period_sat 5 Years satellite Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_sat 0.04 USD per year\u200b (as a fraction of hardware CapEx\u200b) satellite Annual Traffic fee for 1 Mbps of dedicated internet access channel over satellite channel an_traffic_fees_one_mbps_sat 12 USD per Mbps per year satellite Annual ISP fee for 1 Mbps of dedicated internet access channel over satellite channel an_isp_fees_one_mbps_sat 24 USD per Mbps per year satellite Time required to install satellite infrastructure invest_time_sat 0 Years Electricity On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_electricity 0 USD per school\u200b Electricity Reinvest into hardware after reinv_period_electricity 1 Years Electricity Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_electricity 0 USD per year\u200b (as a fraction of hardware CapEx\u200b) Finance Interest rate interest_rate 0.02 Percentage Overall Project planning period pp 10 Years","title":"Class Parameters"},{"location":"costmodel/#class-attributes","text":"Attribute Type Description primary_tech_params pd.DataFrame DataFrame containing technology parameters expansion_factor float Factor for expanding fiber optic cable length in calculations logger logging.Logger Logger instance for logging messages","title":"Class Attributes"},{"location":"costmodel/#methods","text":"Method Return Type Description get_required_keys() list Returns list of required parameter names for cost calculations validate_inputs(primary_tech_params) None Validates the input parameters compute_fiber_costs(poi_num, ch_throughput, focl_length_fiber, pp) pd.DataFrame Calculates fiber network deployment costs compute_p2area_costs(poi_num, ch_throughput, pp) pd.DataFrame Calculates cellular (point-to-area) network deployment costs compute_p2p_costs(poi_num, ch_throughput, pp) pd.DataFrame Calculates point-to-point network deployment costs compute_satellite_costs(poi_num, ch_throughput, pp) pd.DataFrame Calculates satellite network deployment costs compute_electricity_costs(poi_num, pp) pd.DataFrame Calculates electricity costs perform_analysis(poi_data) pd.DataFrame Computes POI-level costs across all technology options for a given dataset The cost calculation methods ( compute_fiber_costs , compute_p2area_costs , compute_p2p_costs , compute_satellite_costs , compute_electricity_costs ) each produce a pd.DataFrame output with the following keys: technology : The technology type being analyzed (in this example \"satellite\", but could also be fiber, p2area, p2p, or electricity) number_poi : Number of points of interest (POIs) included in this calculation ch_throughput : Channel throughput in Mbps (megabits per second) pp : Planning period in years - the time horizon for the analysis pp_profit : Total profit over the entire planning period - calculated as revenue minus cost of ownership pp_profit_per_poi : Average profit per POI over the entire planning period pp_revenue : Total revenue generated over the entire planning period pp_revenue_per_poi : Average revenue per POI over the entire planning period pp_coo : Total cost of ownership over the entire planning period (includes both CAPEX and OPEX) pp_coo_per_poi : Average cost of ownership per POI over the entire planning period init_capex : Initial capital expenditure - the upfront investment required to deploy the technology annual_revenue : Average annual revenue (calculated as total planning period revenue divided by number of years) annual_revenue_per_poi : Average annual revenue per POI annual_cost : Average annual cost (includes CAPEX and OPEX) annual_cost_per_poi : Average annual cost per POI - a key metric for comparing the cost-effectiveness of different technologies The method perform_analysis(poi_data) should be provided with an input DataFrame with the following columns: poi_id : unique identifier (UUID) total_mbps : total throughput in Mbps for each POI (estimated using the Demand module of the toolkit) upstream_node_distance : distance to the nearest transmission node (or connected POI) according the the FiberPath solution. This is the additional length of fiber required to connect the POI to the fiber network. has_electricity : whether the POI is already electrified or not ( bool ). poi_id total_mbps upstream_node_distance has_electricity 09b90515-0ecc-4992-9d39-ae208e1c1fea 415 0 True 0c16c2e8-db92-411b-a6f7-535fb1810e34 1210 0 True 1205e5ef-5d91-47b7-8fc0-11ef019263e5 7640 1682.919 True 1534adf8-b45c-443b-8e1d-87a504e6dc64 865 1887.719 True 192c1704-9e7e-4b7a-8ba7-0eed5ae771ad 79410 906.343 True The output is structured as a multi-indexed pandas DataFrame with the following index levels: poi_id : Unique identifier for each point of interest pp : Planning period (year number from 1 to the total project planning period) technology : Technology type (fiber, p2area, p2p, satellite, electricity) metric : Cost metric (e.g., pp_profit, annual_cost_per_poi, pp_revenue, etc.) The value column contains the actual numerical results for each combination of indices.","title":"Methods"},{"location":"costmodel/#summary-of-cost-models","text":"","title":"Summary of cost models"},{"location":"costmodel/#fiber","text":"Table. Fiber cost model parameters. Technology Parameter Variable name Value Measurement unit fiber On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_fiber 500 USD per school\u200b fiber Fiber optical cable line\u200b construction cost (materials, equipment, labor) focl_constr_cost_fiber 8000 USD per km\u200b fiber Hardware refresh after reinv_period_fiber 5 Years fiber Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_fiber 0.1 USD per year\u200b (as a fraction of hardware CapEx\u200b) fiber Annual transit bandwidth cost for 1 Mbps of dedicated internet access channel over a fiber optic cable line an_traffic_fees_one_mbps_fiber 12 USD per Mbps per year fiber Annual access bandwidth cost for 1 Mbps of dedicated internet access channel over a fiber optic cable line an_isp_fees_one_mbps_fiber 31.8 USD per Mbps per year Figure. Fiber cost model.","title":"Fiber"},{"location":"costmodel/#cellular","text":"Table. Cellular cost model parameters. Technology Parameter Variable name Value Measurement unit p2area On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_p2area 80 USD per school\u200b p2area Reinvest into hardware after reinv_period_p2area 3 Years p2area Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_p2area 0.1 USD per year\u200b (as a fraction of hardware CapEx\u200b) p2area Annual Traffic fee for 1 Mbps of dedicated internet access channel over cellular network an_traffic_fees_one_mbps_p2area 12 USD per Mbps per year p2area Annual ISP fee for 1 Mbps of dedicated internet access channel over cellular network an_isp_fees_one_mbps_p2area 24 USD per Mbps per year p2area Time required to install cellular infrastructure invest_time_p2area 0 Years Figure. Cellular cost model.","title":"Cellular"},{"location":"costmodel/#point-to-point-microwave","text":"Table. Point-to-point microwave cost model parameters. Technology Parameter Variable name Value Measurement unit p2p On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_p2p 500 USD per school\u200b p2p Microwave point-to-point access link installation and comissioning cost (materials, equipment, labor) access_link_setup_p2p 831.59 USD per hop\u200b p2p Number of microwave point-to-point backhaul links backhaul_link_num_p2p 0 Links p2p Microwave point-to-point backhaul link installation and comissioning cost (materials, equipment, labor) backhaul_link_setup_p2p 2825.07 USD per hop\u200b p2p Number of retransmission telecommunication towers retr_tower_num_p2p 0 Towers p2p Retransmission telecommunication tower installation cost retr_tower_inst_p2p 13000 USD per tower p2p Bandwidth per access link access_link_bandwidth_p2p 10 MHz p2p Bandwidth per backhaul link backhaul_link_bandwidth_p2p 20 MHz p2p One time license fee for 1MHz one_time_license_fee_1mhz_p2p 500 USD per MHz p2p Reinvest into hardware after reinv_period_p2p 5 Years p2p Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_p2p 0.004 USD per year\u200b (as a fraction of hardware CapEx\u200b) p2p Annual recurring license fee for 1MHz an_license_fee_1mhz_p2p 100 USD per MHz per year p2p Annual Traffic fee for 1 Mbps of dedicated internet access channel over a P2P microwave link an_traffic_fees_one_mbps_p2p 12 USD per Mbps per year p2p Annual ISP fee for 1 Mbps of dedicated internet access channel over a P2P microwave link an_isp_fees_one_mbps_p2p 24 USD per Mbps per year p2p Time required to install P2P infrastructure invest_time_p2p 0 Years Figure. Point-to-point microwave cost model.","title":"Point-to-point microwave"},{"location":"costmodel/#satellite","text":"Table. Satellite cost model parameters. Technology Parameter Variable name Value Measurement unit satellite On-premises hardware setup cost\u200b (materials, equipment, labor) hw_setup_cost_sat 3000 USD per school\u200b satellite Reinvest into hardware after reinv_period_sat 5 Years satellite Annual hardware maintenance and replacement costs\u200b an_hw_maint_and_repl_sat 0.04 USD per year\u200b (as a fraction of hardware CapEx\u200b) satellite Annual Traffic fee for 1 Mbps of dedicated internet access channel over satellite channel an_traffic_fees_one_mbps_sat 12 USD per Mbps per year satellite Annual ISP fee for 1 Mbps of dedicated internet access channel over satellite channel an_isp_fees_one_mbps_sat 24 USD per Mbps per year Figure. Satellite cost model.","title":"Satellite"},{"location":"costmodel/#example","text":"import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.costmodel.costs import CostModel # 1. Set up your data collections # Points of Interest poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_df = poi_df[[\"poi_id\", \"has_electricity\"]] # Add columns 'total_mbps', 'upstream_node_distance' with random values poi_df['total_mbps'] = np.random.randint(10, 100, size=len(poi_df)) poi_df['upstream_node_distance'] = np.random.uniform(100, 10000, size=len(poi_df)).round(3) # Microeconomic inputs (e.g. cost per km of fiber) cost_inputs_df = pd.read_csv(\"input/cost_inputs.csv\") cost_inputs_df.head() # Variable name Value # 0 hw_setup_cost_fiber 500.0 # 1 focl_constr_cost_fiber 8000.0 # 2 reinv_period_fiber 5.0 # 3 an_hw_maint_and_repl_fiber 0.1 # 4 an_traffic_fees_one_mbps_fiber 12.0 # 2. Create a FiberPath analysis instance costmodel = CostModel(cost_inputs_df, logger=None) # 3. Run the analysis all_costs = costmodel.perform_analysis(poi_df) all_costs.head() # value # poi_id pp technology metric # 09b90515-0ecc-4992-9d39-ae208e1c1fea 1 fiber pp_profit 4430.0 # 0c16c2e8-db92-411b-a6f7-535fb1810e34 1 fiber pp_profit 13970.0 # 1205e5ef-5d91-47b7-8fc0-11ef019263e5 1 fiber pp_profit 74839.3 # 1534adf8-b45c-443b-8e1d-87a504e6dc64 1 fiber pp_profit -8443.1 # 192c1704-9e7e-4b7a-8ba7-0eed5ae771ad 1 fiber pp_profit 943596.6","title":"Example"},{"location":"coverage/","text":"Coverage Overview The Coverage class analyzes telecommunication coverage for points of interest (POIs). It determines whether POIs have access to specific types of telecommunication coverage (2G, 3G, 4G, 5G, or satellite). Key features: Supports multiple analysis methods including coverage maps, proximity to cell sites, and buffer zones Handles different coverage types (2G, 3G, 4G, 5G, satellite) Provides summary statistics and formatted results Class Parameters Required points_of_interest ( PointOfInterestCollection ): Collection of points of interest for analysis. mobile_coverage_type ( str ): Type of coverage to analyze ('2G', '3G', '4G', '5G', 'satellite'). Optional mobile_coverage_data ( geopandas.GeoDataFrame , optional): Coverage polygons with a 'coverage' column. Required when method='map'. cell_sites ( CellSiteCollection , optional): Collection of cell sites. Required when method='cellsites' or 'buffer'. method ( str , default='map'): Analysis method to use: 'map': Uses geographic coverage map polygons 'cellsites': Uses proximity to cell sites 'buffer': Uses buffered areas around cell sites 'all_visible': Assumes all POIs have coverage 'no_visible': Assumes no POIs have coverage search_radius ( int , default=35): Distance in meters for cellsites method. buffer_distance ( int , optional): Buffer size in meters for buffer method. logger ( logging.Logger , optional): Logger instance. If None, a default logger is created. Class attributes points_of_interest : Collection of points of interest cell_sites : Collection of cell sites (if provided) method : Selected analysis method mobile_coverage_data : GeoDataFrame of coverage polygons (if provided) mobile_coverage_type : Type of coverage being analyzed coverage_column : Column name for results (e.g., '4G_coverage') results_table : GeoDataFrame with coverage analysis results analysis_stats : Dictionary with coverage statistics analysis_param : Dictionary for analysis parameters Methods perform_analysis() : Executes coverage analysis using the selected method and prints a summary. get_results_table() : Returns a DataFrame with coverage results in a nested dictionary format. format_analysis_summary() : Returns a human-readable summary of the analysis statistics. Example import pandas as pd import geopandas as gpd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.entities.cellsite import CellSiteCollection from giga_inframapkit.mapping.coverage import Coverage # 1. Set up your data collections poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_collection = PointOfInterestCollection() poi_collection.load_from_records(poi_df.to_dict('records')) # PointOfInterestCollection: 100 entities coverage_data = gpd.read_file(\"input/mobile_coverage_4g.gpkg\") # 2. Create a Coverage analysis instance coverage = Coverage( points_of_interest = poi_collection, mobile_coverage_data = coverage_data, mobile_coverage_type = \"4G\" ) # 3. Run the analysis coverage.perform_analysis() # 4G coverage Analysis Summary: # Number of points of interest: 100 # Number of points of interest covered by signal: 8 # Number of points of interest not covered by signal: 92 # Time taken for analysis: 0.01 seconds coverage.get_results_table() # poi_id coverage # 0 23dd6a45-3656-435b-b3b1-c16efab9daeb {'4G': True} # 1 e13a657c-edf0-4013-92db-6c70136e3ac9 {'4G': False} # 2 de75c87b-2676-47be-8454-4c44c4e6f644 {'4G': False} # 3 4267fc81-0e9f-40ca-84c8-84529958dc22 {'4G': True} # 4 ae0ccc6e-5f91-4a58-a60b-68e8ebcdc797 {'4G': False} # ... ... ... # 95 9b09549f-3f66-4a26-beda-db793cd49363 {'4G': True} # 96 a7a55e1e-6078-4457-89fd-ab69814da42e {'4G': False} # 97 85495887-5439-4f49-82a9-8e0a031b9dc4 {'4G': False} # 98 798ec30c-be58-4b93-9ebb-e6979cf73336 {'4G': False} # 99 96f84def-7438-4e29-b45b-3368a83544ca {'4G': True}","title":"Coverage"},{"location":"coverage/#coverage","text":"","title":"Coverage"},{"location":"coverage/#overview","text":"The Coverage class analyzes telecommunication coverage for points of interest (POIs). It determines whether POIs have access to specific types of telecommunication coverage (2G, 3G, 4G, 5G, or satellite). Key features: Supports multiple analysis methods including coverage maps, proximity to cell sites, and buffer zones Handles different coverage types (2G, 3G, 4G, 5G, satellite) Provides summary statistics and formatted results","title":"Overview"},{"location":"coverage/#class-parameters","text":"","title":"Class Parameters"},{"location":"coverage/#required","text":"points_of_interest ( PointOfInterestCollection ): Collection of points of interest for analysis. mobile_coverage_type ( str ): Type of coverage to analyze ('2G', '3G', '4G', '5G', 'satellite').","title":"Required"},{"location":"coverage/#optional","text":"mobile_coverage_data ( geopandas.GeoDataFrame , optional): Coverage polygons with a 'coverage' column. Required when method='map'. cell_sites ( CellSiteCollection , optional): Collection of cell sites. Required when method='cellsites' or 'buffer'. method ( str , default='map'): Analysis method to use: 'map': Uses geographic coverage map polygons 'cellsites': Uses proximity to cell sites 'buffer': Uses buffered areas around cell sites 'all_visible': Assumes all POIs have coverage 'no_visible': Assumes no POIs have coverage search_radius ( int , default=35): Distance in meters for cellsites method. buffer_distance ( int , optional): Buffer size in meters for buffer method. logger ( logging.Logger , optional): Logger instance. If None, a default logger is created.","title":"Optional"},{"location":"coverage/#class-attributes","text":"points_of_interest : Collection of points of interest cell_sites : Collection of cell sites (if provided) method : Selected analysis method mobile_coverage_data : GeoDataFrame of coverage polygons (if provided) mobile_coverage_type : Type of coverage being analyzed coverage_column : Column name for results (e.g., '4G_coverage') results_table : GeoDataFrame with coverage analysis results analysis_stats : Dictionary with coverage statistics analysis_param : Dictionary for analysis parameters","title":"Class attributes"},{"location":"coverage/#methods","text":"perform_analysis() : Executes coverage analysis using the selected method and prints a summary. get_results_table() : Returns a DataFrame with coverage results in a nested dictionary format. format_analysis_summary() : Returns a human-readable summary of the analysis statistics.","title":"Methods"},{"location":"coverage/#example","text":"import pandas as pd import geopandas as gpd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.entities.cellsite import CellSiteCollection from giga_inframapkit.mapping.coverage import Coverage # 1. Set up your data collections poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_collection = PointOfInterestCollection() poi_collection.load_from_records(poi_df.to_dict('records')) # PointOfInterestCollection: 100 entities coverage_data = gpd.read_file(\"input/mobile_coverage_4g.gpkg\") # 2. Create a Coverage analysis instance coverage = Coverage( points_of_interest = poi_collection, mobile_coverage_data = coverage_data, mobile_coverage_type = \"4G\" ) # 3. Run the analysis coverage.perform_analysis() # 4G coverage Analysis Summary: # Number of points of interest: 100 # Number of points of interest covered by signal: 8 # Number of points of interest not covered by signal: 92 # Time taken for analysis: 0.01 seconds coverage.get_results_table() # poi_id coverage # 0 23dd6a45-3656-435b-b3b1-c16efab9daeb {'4G': True} # 1 e13a657c-edf0-4013-92db-6c70136e3ac9 {'4G': False} # 2 de75c87b-2676-47be-8454-4c44c4e6f644 {'4G': False} # 3 4267fc81-0e9f-40ca-84c8-84529958dc22 {'4G': True} # 4 ae0ccc6e-5f91-4a58-a60b-68e8ebcdc797 {'4G': False} # ... ... ... # 95 9b09549f-3f66-4a26-beda-db793cd49363 {'4G': True} # 96 a7a55e1e-6078-4457-89fd-ab69814da42e {'4G': False} # 97 85495887-5439-4f49-82a9-8e0a031b9dc4 {'4G': False} # 98 798ec30c-be58-4b93-9ebb-e6979cf73336 {'4G': False} # 99 96f84def-7438-4e29-b45b-3368a83544ca {'4G': True}","title":"Example"},{"location":"demand/","text":"Demand Overview The Demand class analyzes population density and bandwidth requirements around points of interest (POIs). It calculates population counts within specified radii and estimates network traffic demand based on general population density. Figure. Population counts around Points of Interest using non-overlapping buffers. Key features: Calculates population distribution within customizable radii around POIs Estimates bandwidth requirements based on population and per-user demand Supports non-overlapping catchment areas using Voronoi diagrams Class Parameters Required points_of_interest ( PointOfInterestCollection ): Collection of points of interest for analysis. population_data_handler ( PopulationDataHandler ): Handler for accessing population data. Optional radii ( list , default=[1, 3, 5]): List of radii in kilometers for population analysis. radius_for_demand ( int , default=1): Specific radius used for traffic demand calculations. mbps_demand_per_user ( int , default=5): Bandwidth demand per user in Mbps. overlap_allowed ( bool , default=False): Whether to allow POI catchment areas to overlap. logger ( logging.Logger , optional): Logger instance. Default created if None. Class Attributes points_of_interest : Collection of points of interest population_data_handler : Handler for population data population_data : Population dataset from the handler radii : List of radii for analysis radius_for_demand : Radius used for traffic calculations mbps_demand_per_user : Bandwidth demand per user overlap_allowed : Boolean flag for catchment area overlap analysis_param : Dictionary of analysis parameters analysis_stats : Dictionary of analysis statistics analysis_results : Dictionary of raw analysis results traffic_demand : DataFrame of bandwidth requirements per POI Methods perform_analysis() : Executes demand analysis based on population distribution around POIs. get_neighbor_population_pixels() : Retrieves population data for neighboring pixels around POIs. get_results_table() : Returns formatted results including traffic demand estimates. get_storage_table() : Returns raw analysis data. format_analysis_summary() : Returns a human-readable summary of analysis statistics. Example import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.handlers.populationdatahandler import PopulationDataHandler from giga_inframapkit.mapping.demand import Demand # 1. Set up your data collections poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_collection = PointOfInterestCollection() poi_collection.load_from_records(poi_df.to_dict('records')) # PointOfInterestCollection: 100 entities # 2. Set up the population data handler, that downloads a raster file with population data into the data_dir - It has a method called population_data, that loads a GeoDataFrame with the values per pixel pop_handler = PopulationDataHandler( data_dir=\"input/population_data\", country_code=\"ESP\", dataset_year=2020, one_km_res=True, un_adjusted=True ) # 3. Create a Demand analysis instance demand = Demand( points_of_interest = poi_collection, population_data_handler = pop_handler, radii = [1, 2, 3], logger = None, overlap_allowed = False, mbps_demand_per_user = 5) # 3. Run the analysis demand.perform_analysis() # Demand Analysis Summary: # Number of points of interest: 100 # Country population count: 46754784.0 # Mean population count of 1km area around a point of interest: 968.88 # Median population count of 1km area around a point of interest: 231.0 # Sum population count of 1km area around a point of interest: 96888 # Mean point of interest count of 1km area around a point of interest: 1.54 # Median point of interest count of 1km area around a point of interest: 1.0 # Sum point of interest count of 1km area around a point of interest: 154 # Mean population count of 2km area around a point of interest: 3164.57 # Median population count of 2km area around a point of interest: 1294.0 # Sum population count of 2km area around a point of interest: 316457 # Mean point of interest count of 2km area around a point of interest: 2.98 # Median point of interest count of 2km area around a point of interest: 3.0 # Sum point of interest count of 2km area around a point of interest: 298 # Mean population count of 3km area around a point of interest: 6401.05 # Median population count of 3km area around a point of interest: 3368.0 # Sum population count of 3km area around a point of interest: 640105 # Mean point of interest count of 3km area around a point of interest: 5.2 # Median point of interest count of 3km area around a point of interest: 5.0 # Sum point of interest count of 3km area around a point of interest: 520 # Time taken for analysis: 0.7 seconds demand.get_results_table() # poi_id population poi_count number_of_users total_mbps # 0 23dd6a45-3656-435b-b3b1-c16efab9daeb {'population_1km': 377, 'population_2km': 2850... {'poi_count_1km': 1, 'poi_count_2km': 4, 'poi_... 377 1885 # 1 e13a657c-edf0-4013-92db-6c70136e3ac9 {'population_1km': 64, 'population_2km': 457, ... {'poi_count_1km': 2, 'poi_count_2km': 6, 'poi_... 64 320 # 2 de75c87b-2676-47be-8454-4c44c4e6f644 {'population_1km': 132, 'population_2km': 662,... {'poi_count_1km': 2, 'poi_count_2km': 3, 'poi_... 132 660 # 3 4267fc81-0e9f-40ca-84c8-84529958dc22 {'population_1km': 233, 'population_2km': 3626... {'poi_count_1km': 1, 'poi_count_2km': 3, 'poi_... 233 1165 # 4 ae0ccc6e-5f91-4a58-a60b-68e8ebcdc797 {'population_1km': 737, 'population_2km': 4656... {'poi_count_1km': 2, 'poi_count_2km': 7, 'poi_... 737 3685","title":"Demand"},{"location":"demand/#demand","text":"","title":"Demand"},{"location":"demand/#overview","text":"The Demand class analyzes population density and bandwidth requirements around points of interest (POIs). It calculates population counts within specified radii and estimates network traffic demand based on general population density. Figure. Population counts around Points of Interest using non-overlapping buffers. Key features: Calculates population distribution within customizable radii around POIs Estimates bandwidth requirements based on population and per-user demand Supports non-overlapping catchment areas using Voronoi diagrams","title":"Overview"},{"location":"demand/#class-parameters","text":"","title":"Class Parameters"},{"location":"demand/#required","text":"points_of_interest ( PointOfInterestCollection ): Collection of points of interest for analysis. population_data_handler ( PopulationDataHandler ): Handler for accessing population data.","title":"Required"},{"location":"demand/#optional","text":"radii ( list , default=[1, 3, 5]): List of radii in kilometers for population analysis. radius_for_demand ( int , default=1): Specific radius used for traffic demand calculations. mbps_demand_per_user ( int , default=5): Bandwidth demand per user in Mbps. overlap_allowed ( bool , default=False): Whether to allow POI catchment areas to overlap. logger ( logging.Logger , optional): Logger instance. Default created if None.","title":"Optional"},{"location":"demand/#class-attributes","text":"points_of_interest : Collection of points of interest population_data_handler : Handler for population data population_data : Population dataset from the handler radii : List of radii for analysis radius_for_demand : Radius used for traffic calculations mbps_demand_per_user : Bandwidth demand per user overlap_allowed : Boolean flag for catchment area overlap analysis_param : Dictionary of analysis parameters analysis_stats : Dictionary of analysis statistics analysis_results : Dictionary of raw analysis results traffic_demand : DataFrame of bandwidth requirements per POI","title":"Class Attributes"},{"location":"demand/#methods","text":"perform_analysis() : Executes demand analysis based on population distribution around POIs. get_neighbor_population_pixels() : Retrieves population data for neighboring pixels around POIs. get_results_table() : Returns formatted results including traffic demand estimates. get_storage_table() : Returns raw analysis data. format_analysis_summary() : Returns a human-readable summary of analysis statistics.","title":"Methods"},{"location":"demand/#example","text":"import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.handlers.populationdatahandler import PopulationDataHandler from giga_inframapkit.mapping.demand import Demand # 1. Set up your data collections poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_collection = PointOfInterestCollection() poi_collection.load_from_records(poi_df.to_dict('records')) # PointOfInterestCollection: 100 entities # 2. Set up the population data handler, that downloads a raster file with population data into the data_dir - It has a method called population_data, that loads a GeoDataFrame with the values per pixel pop_handler = PopulationDataHandler( data_dir=\"input/population_data\", country_code=\"ESP\", dataset_year=2020, one_km_res=True, un_adjusted=True ) # 3. Create a Demand analysis instance demand = Demand( points_of_interest = poi_collection, population_data_handler = pop_handler, radii = [1, 2, 3], logger = None, overlap_allowed = False, mbps_demand_per_user = 5) # 3. Run the analysis demand.perform_analysis() # Demand Analysis Summary: # Number of points of interest: 100 # Country population count: 46754784.0 # Mean population count of 1km area around a point of interest: 968.88 # Median population count of 1km area around a point of interest: 231.0 # Sum population count of 1km area around a point of interest: 96888 # Mean point of interest count of 1km area around a point of interest: 1.54 # Median point of interest count of 1km area around a point of interest: 1.0 # Sum point of interest count of 1km area around a point of interest: 154 # Mean population count of 2km area around a point of interest: 3164.57 # Median population count of 2km area around a point of interest: 1294.0 # Sum population count of 2km area around a point of interest: 316457 # Mean point of interest count of 2km area around a point of interest: 2.98 # Median point of interest count of 2km area around a point of interest: 3.0 # Sum point of interest count of 2km area around a point of interest: 298 # Mean population count of 3km area around a point of interest: 6401.05 # Median population count of 3km area around a point of interest: 3368.0 # Sum population count of 3km area around a point of interest: 640105 # Mean point of interest count of 3km area around a point of interest: 5.2 # Median point of interest count of 3km area around a point of interest: 5.0 # Sum point of interest count of 3km area around a point of interest: 520 # Time taken for analysis: 0.7 seconds demand.get_results_table() # poi_id population poi_count number_of_users total_mbps # 0 23dd6a45-3656-435b-b3b1-c16efab9daeb {'population_1km': 377, 'population_2km': 2850... {'poi_count_1km': 1, 'poi_count_2km': 4, 'poi_... 377 1885 # 1 e13a657c-edf0-4013-92db-6c70136e3ac9 {'population_1km': 64, 'population_2km': 457, ... {'poi_count_1km': 2, 'poi_count_2km': 6, 'poi_... 64 320 # 2 de75c87b-2676-47be-8454-4c44c4e6f644 {'population_1km': 132, 'population_2km': 662,... {'poi_count_1km': 2, 'poi_count_2km': 3, 'poi_... 132 660 # 3 4267fc81-0e9f-40ca-84c8-84529958dc22 {'population_1km': 233, 'population_2km': 3626... {'poi_count_1km': 1, 'poi_count_2km': 3, 'poi_... 233 1165 # 4 ae0ccc6e-5f91-4a58-a60b-68e8ebcdc797 {'population_1km': 737, 'population_2km': 4656... {'poi_count_1km': 2, 'poi_count_2km': 7, 'poi_... 737 3685","title":"Example"},{"location":"fiberpath/","text":"Fiber path Overview The fiber path model identifies the shortest and most cost-effective paths for connecting unconnected points of interest (POIs) to the existing optical fiber network using the road network. By minimizing the total length of fiber required, this model reduces overall deployment costs while efficiently extending connectivity. To start with, the model connects POIs and fiber nodes to the existing road network using straight lines (unless they are already on the road network). Then, for each unconnected POI, it computes the shortest path to all fiber nodes. POIs that are already connected to the fiber network can also act as fiber nodes, from which the fiber network can be extended. Figure: Graph initialization and fiber path algorithm At each step of the algorithm, new connections are made between connected and unconnected points as long as the length of the new connection is below a specified threshold. For example, it can be specified that no single fiber line should be longer than 5 kilometers. This approach enables economies of scale: POIs can act as relay points for neighboring POIs, enabling connectivity without each one needing to connect directly to a transmission node. This approach optimizes resource usage and simplifies network expansion. In practice, this model is an application of Kruskal's algorithm to find a Minimum Spanning Tree (MST) in a network graph, where the edges are the road network and the vertices are POIs and fiber nodes. The MST ensures the minimal fiber path necessary to connect all relevant points while adhering to road network constraints related to distance. Figure: Output of fiber path algorithm Key features: Plans optimal fiber paths using road networks or direct line-of-sight connections Supports clustering analysis for faster computations and regional planning Incorporates scale economies, allowing POIs to connect to other connected POIs Optimizes based on physical distance or operator profits (thus findings the paths that connect all POIs, while maximizing the potential revenue by laying down fiber through the most populous zones) Class Parameters Parameter Type Default Description points_of_interest PointOfInterestCollection Required Collection of points of interest to be connected transmission_nodes TransmissionNodeCollection Required Collection of transmission infrastructure nodes to connect to max_connection_distance int Required Maximum connection distance in meters using the selected distance_metric use_road_data bool Required If True, use road networks; if False, use direct line-of-sight scale_economies bool True If True, POIs can connect to other connected POIs; if False, POIs can only connect to transmission nodes n_clusters int None Number of clusters for analysis. If None, clustering is based on distance. If 1, no clustering is performed constrained bool False If True, each cluster must contain at least one transmission node network_type str 'all' Road network type ('all', 'bike', 'walk', etc.) random_state int 0 Seed for random operations distance_metric str 'length' Metric to optimize: 'length' (physical distance) or 'net_cost' (cost minus revenue) revenue_per_pop int 10 Estimated revenue per person along the fiber path fiber_cost_per_km int 5 Cost of fiber per kilometer population_handler PopulationDataHandler None Required for net_cost distance metric logger Logger None Logger instance for capturing messages. If None, a default logger will be created Class Attributes Attribute Type Description points_of_interest PointOfInterestCollection Original collection of POIs transmission_nodes TransmissionNodeCollection Original collection of transmission nodes all_collection EntityCollection Combined collection of POIs and transmission nodes max_connection_distance int Maximum allowed connection distance use_road_data bool Flag indicating whether to use road data or line-of-sight scale_economies bool Flag indicating whether POIs can connect to other connected POIs n_clusters int Number of clusters for analysis distance_metric str Metric used for optimization analysis_param dict Dictionary storing configuration parameters analysis_stats dict Dictionary storing statistics (counts, lengths, times) fiber_path_dict dict Dictionary storing path information for each POI fiber_path_nodes DataFrame DataFrame containing nodes in the fiber path network fiber_path_edges DataFrame DataFrame containing edges in the fiber path network Methods Method Return Type Description perform_analysis(save_cache=True, use_cache=True, not_connected_only=False) str Executes the fiber path analysis with options for caching and incremental processing perform_multilength_analysis(max_connection_distances) None Runs analysis for multiple maximum connection distances get_results_table() DataFrame Returns fiber path information for each connected POI get_fp_edges_table() DataFrame Returns fiber path edges get_fp_nodes_table() DataFrame Returns fiber path nodes format_analysis_summary() str Formats the analysis statistics as a human-readable string summary connect_pois(graph_pdn, connected_idx, unconnected_idx, remainder_idx, graph_nx) tuple Connects unconnected POIs to the nearest connected point dynamically extract_paths(graph_pdn, fiber_path_dict) DataFrame Extracts fiber paths from the graph based on the fiber path dictionary get_fiber_path_graph(graph, paths) nx.MultiGraph Gets a graph representation of fiber paths get_fiber_path_nodes_edges(fiber_path_graph) dict Gets nodes and edges from the fiber path graph path_total_from_nx_graph(graph, node_list, metric) float Calculates the total path length or cost Outputs The get_results_table() method produces a DataFrame with the following columns: closest_node_id closest_node_distance connected_node_id connected_node_distance fiber_path upstream_node_id upstream_node_distance These are summarized in the diagram below. In this example, the points of interest are schools. Example import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.entities.transmissionnode import TransmissionNodeCollection from giga_inframapkit.fiberpath.fiberpath import FiberPath # 1. Set up your data collections poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_collection = PointOfInterestCollection() poi_collection.load_from_records(poi_df.to_dict('records')) transmission_node_df = pd.read_csv(\"input/transmission_nodes.csv\") transmission_node_collection = TransmissionNodeCollection() transmission_node_collection.load_from_records(transmission_node_df.to_dict('records')) # PointOfInterestCollection: 100 entities # TransmissionNodeCollection: 30 entities # 2. Create a FiberPath analysis instance fiberpath = FiberPath( points_of_interest = poi_collection, transmission_nodes = transmission_node_collection, max_connection_distance = 10000, # 1km use_road_data = True, n_clusters = 1, # No clustering of POIs constrained = False, network_type = \"all\", random_state = 9, distance_metric = \"length\", logger = None ) # 3. Run the analysis fiberpath.perform_analysis() # INFO:fiberpath_ESP:Running analysis without clustering... # INFO:fiberpath_ESP:Processing population tif file... # INFO:fiberpath_ESP:Population tif file is processed! # INFO:fiberpath_ESP:Dynamically connecting points of interest... # Generating contraction hierarchies with 8 threads. # Setting CH node vector of size 35771 # Setting CH edge vector of size 42545 # Range graph removed 1186 edges of 85090 # . 10% . 20% . 30% . 40% . 50% . 60% . 70% . 80% . 90% . 100% # Generating contraction hierarchies with 8 threads. # Setting CH node vector of size 35771 # Setting CH edge vector of size 42545 # Range graph removed 1186 edges of 85090 # . 10% . 20% . 30% . 40% . 50% . 60% . 70% . 80% . 90% . 100% # Fiber Path Analysis Summary: # Number of points of interest: 100 # Number of transmission nodes: 30 # Number of unconnected points of interest in the original dataset: 100 # Fiber path length (km): 277.59 # Number of newly connected points of interest by fiber path: 100 # Number of points of interest that cannot be connected by fiber path: 0 # Time taken for analysis: 30.68 seconds fiberpath_results = fiberpath.get_results_table() fiberpath_results.head() # poi_id closest_node_id closest_node_distance connected_node_id connected_node_distance fiber_path upstream_node_id upstream_node_distance max_dist_km in_mst_solution n_conns # 0 f01b7a6c-8d4e-4a7c-89f8-ef79eff4aab5 b7e56176-ea86-45a8-b494-4a9cefb4a75b 4474.282580 4c378326-6260-476a-bf24-8862b7ada7e0 21846.181627 [4c378326-6260-476a-bf24-8862b7ada7e0, e8fc47f... d94433a9-0da0-4fd5-af57-ddfb321fc525 3792.344302 inf True 5 # 1 3c1b571e-ab30-4c81-832d-51bdfef51bba c530d19a-1e10-4efb-83b3-69dd6d8dca30 1157.624367 c530d19a-1e10-4efb-83b3-69dd6d8dca30 1157.624367 [c530d19a-1e10-4efb-83b3-69dd6d8dca30] c530d19a-1e10-4efb-83b3-69dd6d8dca30 1157.624367 inf True 1 # 2 03116452-1288-434e-83d5-fed21199c4a8 090dcd28-f45e-42b6-be51-73fa90b3e7f7 916.358942 090dcd28-f45e-42b6-be51-73fa90b3e7f7 916.358942 [090dcd28-f45e-42b6-be51-73fa90b3e7f7] 090dcd28-f45e-42b6-be51-73fa90b3e7f7 916.358942 inf True 1 # 3 775b863e-688e-45e8-b12e-956a3144bd35 541c5949-ab47-4a42-83df-2f5653718d5a 5241.324763 926790f6-1345-4cab-92eb-0d28185e2d54 15337.141260 [926790f6-1345-4cab-92eb-0d28185e2d54, 20de279... 0b373675-de87-476b-9262-a0f7d9fe97c7 1635.844092 inf True 5 # 4 9c0cf673-558f-47f4-b008-68872ebfd0a1 0430c874-2cc1-4b96-858f-07bddf5de495 3372.765524 0430c874-2cc1-4b96-858f-07bddf5de495 3687.584338 [0430c874-2cc1-4b96-858f-07bddf5de495, bbd7b66... 8955c08a-d3a8-4dd0-872a-09489285a97a 2342.884136 inf True 3","title":"Fiber path"},{"location":"fiberpath/#fiber-path","text":"","title":"Fiber path"},{"location":"fiberpath/#overview","text":"The fiber path model identifies the shortest and most cost-effective paths for connecting unconnected points of interest (POIs) to the existing optical fiber network using the road network. By minimizing the total length of fiber required, this model reduces overall deployment costs while efficiently extending connectivity. To start with, the model connects POIs and fiber nodes to the existing road network using straight lines (unless they are already on the road network). Then, for each unconnected POI, it computes the shortest path to all fiber nodes. POIs that are already connected to the fiber network can also act as fiber nodes, from which the fiber network can be extended. Figure: Graph initialization and fiber path algorithm At each step of the algorithm, new connections are made between connected and unconnected points as long as the length of the new connection is below a specified threshold. For example, it can be specified that no single fiber line should be longer than 5 kilometers. This approach enables economies of scale: POIs can act as relay points for neighboring POIs, enabling connectivity without each one needing to connect directly to a transmission node. This approach optimizes resource usage and simplifies network expansion. In practice, this model is an application of Kruskal's algorithm to find a Minimum Spanning Tree (MST) in a network graph, where the edges are the road network and the vertices are POIs and fiber nodes. The MST ensures the minimal fiber path necessary to connect all relevant points while adhering to road network constraints related to distance. Figure: Output of fiber path algorithm Key features: Plans optimal fiber paths using road networks or direct line-of-sight connections Supports clustering analysis for faster computations and regional planning Incorporates scale economies, allowing POIs to connect to other connected POIs Optimizes based on physical distance or operator profits (thus findings the paths that connect all POIs, while maximizing the potential revenue by laying down fiber through the most populous zones)","title":"Overview"},{"location":"fiberpath/#class-parameters","text":"Parameter Type Default Description points_of_interest PointOfInterestCollection Required Collection of points of interest to be connected transmission_nodes TransmissionNodeCollection Required Collection of transmission infrastructure nodes to connect to max_connection_distance int Required Maximum connection distance in meters using the selected distance_metric use_road_data bool Required If True, use road networks; if False, use direct line-of-sight scale_economies bool True If True, POIs can connect to other connected POIs; if False, POIs can only connect to transmission nodes n_clusters int None Number of clusters for analysis. If None, clustering is based on distance. If 1, no clustering is performed constrained bool False If True, each cluster must contain at least one transmission node network_type str 'all' Road network type ('all', 'bike', 'walk', etc.) random_state int 0 Seed for random operations distance_metric str 'length' Metric to optimize: 'length' (physical distance) or 'net_cost' (cost minus revenue) revenue_per_pop int 10 Estimated revenue per person along the fiber path fiber_cost_per_km int 5 Cost of fiber per kilometer population_handler PopulationDataHandler None Required for net_cost distance metric logger Logger None Logger instance for capturing messages. If None, a default logger will be created","title":"Class Parameters"},{"location":"fiberpath/#class-attributes","text":"Attribute Type Description points_of_interest PointOfInterestCollection Original collection of POIs transmission_nodes TransmissionNodeCollection Original collection of transmission nodes all_collection EntityCollection Combined collection of POIs and transmission nodes max_connection_distance int Maximum allowed connection distance use_road_data bool Flag indicating whether to use road data or line-of-sight scale_economies bool Flag indicating whether POIs can connect to other connected POIs n_clusters int Number of clusters for analysis distance_metric str Metric used for optimization analysis_param dict Dictionary storing configuration parameters analysis_stats dict Dictionary storing statistics (counts, lengths, times) fiber_path_dict dict Dictionary storing path information for each POI fiber_path_nodes DataFrame DataFrame containing nodes in the fiber path network fiber_path_edges DataFrame DataFrame containing edges in the fiber path network","title":"Class Attributes"},{"location":"fiberpath/#methods","text":"Method Return Type Description perform_analysis(save_cache=True, use_cache=True, not_connected_only=False) str Executes the fiber path analysis with options for caching and incremental processing perform_multilength_analysis(max_connection_distances) None Runs analysis for multiple maximum connection distances get_results_table() DataFrame Returns fiber path information for each connected POI get_fp_edges_table() DataFrame Returns fiber path edges get_fp_nodes_table() DataFrame Returns fiber path nodes format_analysis_summary() str Formats the analysis statistics as a human-readable string summary connect_pois(graph_pdn, connected_idx, unconnected_idx, remainder_idx, graph_nx) tuple Connects unconnected POIs to the nearest connected point dynamically extract_paths(graph_pdn, fiber_path_dict) DataFrame Extracts fiber paths from the graph based on the fiber path dictionary get_fiber_path_graph(graph, paths) nx.MultiGraph Gets a graph representation of fiber paths get_fiber_path_nodes_edges(fiber_path_graph) dict Gets nodes and edges from the fiber path graph path_total_from_nx_graph(graph, node_list, metric) float Calculates the total path length or cost","title":"Methods"},{"location":"fiberpath/#outputs","text":"The get_results_table() method produces a DataFrame with the following columns: closest_node_id closest_node_distance connected_node_id connected_node_distance fiber_path upstream_node_id upstream_node_distance These are summarized in the diagram below. In this example, the points of interest are schools.","title":"Outputs"},{"location":"fiberpath/#example","text":"import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.entities.transmissionnode import TransmissionNodeCollection from giga_inframapkit.fiberpath.fiberpath import FiberPath # 1. Set up your data collections poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_collection = PointOfInterestCollection() poi_collection.load_from_records(poi_df.to_dict('records')) transmission_node_df = pd.read_csv(\"input/transmission_nodes.csv\") transmission_node_collection = TransmissionNodeCollection() transmission_node_collection.load_from_records(transmission_node_df.to_dict('records')) # PointOfInterestCollection: 100 entities # TransmissionNodeCollection: 30 entities # 2. Create a FiberPath analysis instance fiberpath = FiberPath( points_of_interest = poi_collection, transmission_nodes = transmission_node_collection, max_connection_distance = 10000, # 1km use_road_data = True, n_clusters = 1, # No clustering of POIs constrained = False, network_type = \"all\", random_state = 9, distance_metric = \"length\", logger = None ) # 3. Run the analysis fiberpath.perform_analysis() # INFO:fiberpath_ESP:Running analysis without clustering... # INFO:fiberpath_ESP:Processing population tif file... # INFO:fiberpath_ESP:Population tif file is processed! # INFO:fiberpath_ESP:Dynamically connecting points of interest... # Generating contraction hierarchies with 8 threads. # Setting CH node vector of size 35771 # Setting CH edge vector of size 42545 # Range graph removed 1186 edges of 85090 # . 10% . 20% . 30% . 40% . 50% . 60% . 70% . 80% . 90% . 100% # Generating contraction hierarchies with 8 threads. # Setting CH node vector of size 35771 # Setting CH edge vector of size 42545 # Range graph removed 1186 edges of 85090 # . 10% . 20% . 30% . 40% . 50% . 60% . 70% . 80% . 90% . 100% # Fiber Path Analysis Summary: # Number of points of interest: 100 # Number of transmission nodes: 30 # Number of unconnected points of interest in the original dataset: 100 # Fiber path length (km): 277.59 # Number of newly connected points of interest by fiber path: 100 # Number of points of interest that cannot be connected by fiber path: 0 # Time taken for analysis: 30.68 seconds fiberpath_results = fiberpath.get_results_table() fiberpath_results.head() # poi_id closest_node_id closest_node_distance connected_node_id connected_node_distance fiber_path upstream_node_id upstream_node_distance max_dist_km in_mst_solution n_conns # 0 f01b7a6c-8d4e-4a7c-89f8-ef79eff4aab5 b7e56176-ea86-45a8-b494-4a9cefb4a75b 4474.282580 4c378326-6260-476a-bf24-8862b7ada7e0 21846.181627 [4c378326-6260-476a-bf24-8862b7ada7e0, e8fc47f... d94433a9-0da0-4fd5-af57-ddfb321fc525 3792.344302 inf True 5 # 1 3c1b571e-ab30-4c81-832d-51bdfef51bba c530d19a-1e10-4efb-83b3-69dd6d8dca30 1157.624367 c530d19a-1e10-4efb-83b3-69dd6d8dca30 1157.624367 [c530d19a-1e10-4efb-83b3-69dd6d8dca30] c530d19a-1e10-4efb-83b3-69dd6d8dca30 1157.624367 inf True 1 # 2 03116452-1288-434e-83d5-fed21199c4a8 090dcd28-f45e-42b6-be51-73fa90b3e7f7 916.358942 090dcd28-f45e-42b6-be51-73fa90b3e7f7 916.358942 [090dcd28-f45e-42b6-be51-73fa90b3e7f7] 090dcd28-f45e-42b6-be51-73fa90b3e7f7 916.358942 inf True 1 # 3 775b863e-688e-45e8-b12e-956a3144bd35 541c5949-ab47-4a42-83df-2f5653718d5a 5241.324763 926790f6-1345-4cab-92eb-0d28185e2d54 15337.141260 [926790f6-1345-4cab-92eb-0d28185e2d54, 20de279... 0b373675-de87-476b-9262-a0f7d9fe97c7 1635.844092 inf True 5 # 4 9c0cf673-558f-47f4-b008-68872ebfd0a1 0430c874-2cc1-4b96-858f-07bddf5de495 3372.765524 0430c874-2cc1-4b96-858f-07bddf5de495 3687.584338 [0430c874-2cc1-4b96-858f-07bddf5de495, bbd7b66... 8955c08a-d3a8-4dd0-872a-09489285a97a 2342.884136 inf True 3","title":"Example"},{"location":"inputdata/","text":"Datasets This page summarizes the data user-provided required by the toolkit. The provided data must conform to the standards below. Points of interest (POI) Column name Column type Levels Example Mandatory Definition poi_id UUID 123e4567-e89b-12d3-a456-426614174000 Yes Unique identifier for the POI dataset_id UUID 987fcdeb-51a2-12d3-a456-426614174000 Yes Unique identifier for the dataset lat float 36.7538 Yes Latitude coordinate lon float 3.0588 Yes Longitude coordinate poi_type string school No Type of point of interest is_public boolean True No Whether the POI is public or private poi_subtype string primary school No Specific subtype of the POI country_code string DZA Yes ISO 3166-1 alpha-3 country code is_connected boolean True Yes Whether the POI has connectivity connectivity_type string fiber Yes Type of internet connectivity Cell sites Column name Column type Levels Example Mandatory Definition ict_id UUID 123e4567-e89b-12d3-a456-426614174000 Yes Cell tower identifier dataset_id UUID 987fcdeb-51a2-12d3-a456-426614174000 Yes Unique identifier for the dataset latitude float 38.988755 Yes Cell tower geographical latitude longitude float 1.401938 Yes Cell tower geographical longitude operator_name string TelOperator No Mobile network operator name radio_type string 2G, 3G, 4G, 5G 4G Yes Type of radio transmission technology antenna_height_m float 25 Yes Antenna height on the tower or building backhaul_type string fiber, microwave, satellite fiber No Type of backhaul connectivity of the cell tower backhaul_throughput_mbps float 1000 No Equipped throughput of the backhaul Transmission nodes Column name Column type Levels Example Mandatory Definition ict_id UUID 123e4567-e89b-12d3-a456-426614174000 Yes Node identifier dataset_id UUID 987fcdeb-51a2-12d3-a456-426614174000 Yes Unique identifier for the dataset latitude float 38.988755 Yes Geographical latitude longitude float 1.401938 Yes Geographical longitude operator_name string TelOperator No Name of the mobile operator infrastructure_type string fiber, microwave, other fiber Yes Type of Infrastructure node_status string operational, planned, under construction operational Yes Status of the node equipped_capacity_mbps float 1000 No Equipped bandwidth ready for use to connect subscribers potential_capacity_mbps float 2000 No Total theoretical bandwidth available for subscriber connections Mobile coverage Column name Column type Levels Example Mandatory Definition fid str 123e4567-e89b-12d3-a456-426614174000 Yes Unique identifier for polygons coverage int 1 Yes Should be equal to 1 for all rows geometry geometry POLYGON((-74.0060 40.7128, -73.9857 40.7484, -73.9772 40.7516, -74.0060 40.7128)) Yes Mobile coverage polygons","title":"Input data"},{"location":"inputdata/#datasets","text":"This page summarizes the data user-provided required by the toolkit. The provided data must conform to the standards below.","title":"Datasets"},{"location":"inputdata/#points-of-interest-poi","text":"Column name Column type Levels Example Mandatory Definition poi_id UUID 123e4567-e89b-12d3-a456-426614174000 Yes Unique identifier for the POI dataset_id UUID 987fcdeb-51a2-12d3-a456-426614174000 Yes Unique identifier for the dataset lat float 36.7538 Yes Latitude coordinate lon float 3.0588 Yes Longitude coordinate poi_type string school No Type of point of interest is_public boolean True No Whether the POI is public or private poi_subtype string primary school No Specific subtype of the POI country_code string DZA Yes ISO 3166-1 alpha-3 country code is_connected boolean True Yes Whether the POI has connectivity connectivity_type string fiber Yes Type of internet connectivity","title":"Points of interest (POI)"},{"location":"inputdata/#cell-sites","text":"Column name Column type Levels Example Mandatory Definition ict_id UUID 123e4567-e89b-12d3-a456-426614174000 Yes Cell tower identifier dataset_id UUID 987fcdeb-51a2-12d3-a456-426614174000 Yes Unique identifier for the dataset latitude float 38.988755 Yes Cell tower geographical latitude longitude float 1.401938 Yes Cell tower geographical longitude operator_name string TelOperator No Mobile network operator name radio_type string 2G, 3G, 4G, 5G 4G Yes Type of radio transmission technology antenna_height_m float 25 Yes Antenna height on the tower or building backhaul_type string fiber, microwave, satellite fiber No Type of backhaul connectivity of the cell tower backhaul_throughput_mbps float 1000 No Equipped throughput of the backhaul","title":"Cell sites"},{"location":"inputdata/#transmission-nodes","text":"Column name Column type Levels Example Mandatory Definition ict_id UUID 123e4567-e89b-12d3-a456-426614174000 Yes Node identifier dataset_id UUID 987fcdeb-51a2-12d3-a456-426614174000 Yes Unique identifier for the dataset latitude float 38.988755 Yes Geographical latitude longitude float 1.401938 Yes Geographical longitude operator_name string TelOperator No Name of the mobile operator infrastructure_type string fiber, microwave, other fiber Yes Type of Infrastructure node_status string operational, planned, under construction operational Yes Status of the node equipped_capacity_mbps float 1000 No Equipped bandwidth ready for use to connect subscribers potential_capacity_mbps float 2000 No Total theoretical bandwidth available for subscriber connections","title":"Transmission nodes"},{"location":"inputdata/#mobile-coverage","text":"Column name Column type Levels Example Mandatory Definition fid str 123e4567-e89b-12d3-a456-426614174000 Yes Unique identifier for polygons coverage int 1 Yes Should be equal to 1 for all rows geometry geometry POLYGON((-74.0060 40.7128, -73.9857 40.7484, -73.9772 40.7516, -74.0060 40.7128)) Yes Mobile coverage polygons","title":"Mobile coverage"},{"location":"integrations/","text":"Model integration The diagram below summarizes how the datasets are used by each model, and how the different models can be used together in an integrated way. In the first step, the Proximity, Coverage, Demand, Visibility and Fiber Path models assess the feasibility of four technologies below. Figure. Technologies. In the second step, the Cost and Technology Assignment models determine the optimal connectivity solution for each Point of Interest (POI). Figure. Integration between toolkit models.","title":"Model integations"},{"location":"integrations/#model-integration","text":"The diagram below summarizes how the datasets are used by each model, and how the different models can be used together in an integrated way. In the first step, the Proximity, Coverage, Demand, Visibility and Fiber Path models assess the feasibility of four technologies below. Figure. Technologies. In the second step, the Cost and Technology Assignment models determine the optimal connectivity solution for each Point of Interest (POI). Figure. Integration between toolkit models.","title":"Model integration"},{"location":"proximity/","text":"Proximity Overview The Proximity class calculates distances between points of interest (POIs) and telecommunications infrastructure elements. It performs spatial analysis to find the nearest cell sites and transmission nodes for each POI. Key features: Calculates distances to the nearest infrastructure elements by type (2G/3G/4G/5G cell sites, fiber nodes) Uses Haversine formula to account for Earth's curvature in distance calculations Efficiently processes large datasets using k-d trees for nearest-neighbor searches Provides both raw distance data and summary statistics Class parameters Required points_of_interest ( PointOfInterestCollection ): Collection of points of interest for which proximity will be calculated. cell_sites ( CellSiteCollection ): Collection of cell site locations with attributes including radio type (2G, 3G, 4G, 5G). transmission_nodes ( TransmissionNodeCollection ): Collection of transmission infrastructure nodes with attributes including transmission medium type. Optional logger ( logging.Logger , optional): Logger instance for capturing messages. If None, a default logger will be created. Class attributes points_of_interest : Original collection of POIs cell_sites : Original collection of all cell sites transmission_nodes : Original collection of all transmission nodes cell_sites_2g/3g/4g/5g : Filtered collections by radio type transmission_nodes_fiber : Filtered collection of fiber-based transmission nodes analysis_param : Dictionary for storing configuration parameters analysis_stats : Dictionary storing statistics (counts of elements, mean distances) analysis_results : Dictionary storing raw results (distances from each POI to infrastructure) Methods perform_analysis() : Executes the proximity analysis for all POIs and infrastructure elements. get_results_table() : Returns a formatted DataFrame with the analysis results in a structured format. get_storage_table() : Returns a DataFrame with the raw analysis results. format_analysis_summary() : Formats the analysis statistics as a human-readable string summary. Example import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.entities.cellsite import CellSiteCollection from giga_inframapkit.entities.transmissionnode import TransmissionNodeCollection from giga_inframapkit.proximity import Proximity # 1. Set up your data collections dataset_ids = { 'pointofinterest': 'points_of_interest.csv', 'cellsite': 'cell_sites.csv', 'transmissionnode': 'transmission_nodes.csv' } data_collections = { 'pointofinterest': PointOfInterestCollection(), 'cellsite': CellSiteCollection(), 'transmissionnode': TransmissionNodeCollection() } for data_category, filepath in dataset_ids.items(): df = pd.read_csv(f\"input/{filepath}\").to_dict('records') data_collections[data_category].load_from_records(records) # PointOfInterestCollection: 100 entities # CellSiteCollection: 100 entities # TransmissionNodeCollection: 30 entities # 2. Create a Proximity analysis instance proximity = Proximity( points_of_interest=poi_collection, cell_sites=cell_sites, transmission_nodes=transmission_nodes ) # 3. Run the analysis proximity.perform_analysis() # Proximity Analysis Summary: # Number of points of interest: 100 # Number of cell sites: 100 # Number of transmission nodes: 30 # Number of 2G cell sites: 6 # Number of 3G cell sites: 30 # Number of 4G cell sites: 64 # Number of 5G cell sites: 0 # Number of fiber nodes: 30 # Mean cell site distance: 1267.17 # Mean transmission node distance: 2451.69 # Mean 2G cell site distance: 5647.04 # Mean 3G cell site distance: 2419.78 # Mean 4G cell site distance: 1606.58 # Mean fiber node distance: 2451.69 # Time taken for analysis: 0.0 seconds # 4. Inspect output p_results = proximity.get_results_table() p_results.head() # poi_id cell_site_dist transmission_node_dist # 0 23dd6a45-3656-435b-b3b1-c16efab9daeb {'any': 1158, '2G': 2365, '3G': 2475, '4G': 11... {'any': 2559, 'fiber': 2559} # 1 e13a657c-edf0-4013-92db-6c70136e3ac9 {'any': 2817, '2G': 10258, '3G': 3967, '4G': 2... {'any': 1808, 'fiber': 1808} # 2 de75c87b-2676-47be-8454-4c44c4e6f644 {'any': 646, '2G': 4049, '3G': 1086, '4G': 646... {'any': 3183, 'fiber': 3183} # 3 4267fc81-0e9f-40ca-84c8-84529958dc22 {'any': 1066, '2G': 1066, '3G': 2863, '4G': 13... {'any': 1678, 'fiber': 1678} # 4 ae0ccc6e-5f91-4a58-a60b-68e8ebcdc797 {'any': 462, '2G': 7196, '3G': 2288, '4G': 462... {'any': 1615, 'fiber': 1615}","title":"Proximity"},{"location":"proximity/#proximity","text":"","title":"Proximity"},{"location":"proximity/#overview","text":"The Proximity class calculates distances between points of interest (POIs) and telecommunications infrastructure elements. It performs spatial analysis to find the nearest cell sites and transmission nodes for each POI. Key features: Calculates distances to the nearest infrastructure elements by type (2G/3G/4G/5G cell sites, fiber nodes) Uses Haversine formula to account for Earth's curvature in distance calculations Efficiently processes large datasets using k-d trees for nearest-neighbor searches Provides both raw distance data and summary statistics","title":"Overview"},{"location":"proximity/#class-parameters","text":"","title":"Class parameters"},{"location":"proximity/#required","text":"points_of_interest ( PointOfInterestCollection ): Collection of points of interest for which proximity will be calculated. cell_sites ( CellSiteCollection ): Collection of cell site locations with attributes including radio type (2G, 3G, 4G, 5G). transmission_nodes ( TransmissionNodeCollection ): Collection of transmission infrastructure nodes with attributes including transmission medium type.","title":"Required"},{"location":"proximity/#optional","text":"logger ( logging.Logger , optional): Logger instance for capturing messages. If None, a default logger will be created.","title":"Optional"},{"location":"proximity/#class-attributes","text":"points_of_interest : Original collection of POIs cell_sites : Original collection of all cell sites transmission_nodes : Original collection of all transmission nodes cell_sites_2g/3g/4g/5g : Filtered collections by radio type transmission_nodes_fiber : Filtered collection of fiber-based transmission nodes analysis_param : Dictionary for storing configuration parameters analysis_stats : Dictionary storing statistics (counts of elements, mean distances) analysis_results : Dictionary storing raw results (distances from each POI to infrastructure)","title":"Class attributes"},{"location":"proximity/#methods","text":"perform_analysis() : Executes the proximity analysis for all POIs and infrastructure elements. get_results_table() : Returns a formatted DataFrame with the analysis results in a structured format. get_storage_table() : Returns a DataFrame with the raw analysis results. format_analysis_summary() : Formats the analysis statistics as a human-readable string summary.","title":"Methods"},{"location":"proximity/#example","text":"import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.entities.cellsite import CellSiteCollection from giga_inframapkit.entities.transmissionnode import TransmissionNodeCollection from giga_inframapkit.proximity import Proximity # 1. Set up your data collections dataset_ids = { 'pointofinterest': 'points_of_interest.csv', 'cellsite': 'cell_sites.csv', 'transmissionnode': 'transmission_nodes.csv' } data_collections = { 'pointofinterest': PointOfInterestCollection(), 'cellsite': CellSiteCollection(), 'transmissionnode': TransmissionNodeCollection() } for data_category, filepath in dataset_ids.items(): df = pd.read_csv(f\"input/{filepath}\").to_dict('records') data_collections[data_category].load_from_records(records) # PointOfInterestCollection: 100 entities # CellSiteCollection: 100 entities # TransmissionNodeCollection: 30 entities # 2. Create a Proximity analysis instance proximity = Proximity( points_of_interest=poi_collection, cell_sites=cell_sites, transmission_nodes=transmission_nodes ) # 3. Run the analysis proximity.perform_analysis() # Proximity Analysis Summary: # Number of points of interest: 100 # Number of cell sites: 100 # Number of transmission nodes: 30 # Number of 2G cell sites: 6 # Number of 3G cell sites: 30 # Number of 4G cell sites: 64 # Number of 5G cell sites: 0 # Number of fiber nodes: 30 # Mean cell site distance: 1267.17 # Mean transmission node distance: 2451.69 # Mean 2G cell site distance: 5647.04 # Mean 3G cell site distance: 2419.78 # Mean 4G cell site distance: 1606.58 # Mean fiber node distance: 2451.69 # Time taken for analysis: 0.0 seconds # 4. Inspect output p_results = proximity.get_results_table() p_results.head() # poi_id cell_site_dist transmission_node_dist # 0 23dd6a45-3656-435b-b3b1-c16efab9daeb {'any': 1158, '2G': 2365, '3G': 2475, '4G': 11... {'any': 2559, 'fiber': 2559} # 1 e13a657c-edf0-4013-92db-6c70136e3ac9 {'any': 2817, '2G': 10258, '3G': 3967, '4G': 2... {'any': 1808, 'fiber': 1808} # 2 de75c87b-2676-47be-8454-4c44c4e6f644 {'any': 646, '2G': 4049, '3G': 1086, '4G': 646... {'any': 3183, 'fiber': 3183} # 3 4267fc81-0e9f-40ca-84c8-84529958dc22 {'any': 1066, '2G': 1066, '3G': 2863, '4G': 13... {'any': 1678, 'fiber': 1678} # 4 ae0ccc6e-5f91-4a58-a60b-68e8ebcdc797 {'any': 462, '2G': 7196, '3G': 2288, '4G': 462... {'any': 1615, 'fiber': 1615}","title":"Example"},{"location":"visibility/","text":"Visibility The Visibility module provides tools to analyze line-of-sight connectivity between different infrastructure components. It determines whether points of interest (POIs) have clear line-of-sight with cell sites or with other POIs, accounting for terrain elevation, Earth's curvature, and antenna heights. Line-of-sight is required to establish the feasibility of radio links between points of interest (POIs) and cell sites using visibility analysis. The analysis uses open topography data from the Shuttle Radar Topography Mission (SRTM), which provides 30-meter resolution elevation data. Figure: Visible cell site Figure: Obstructed cell site Key Features: Line-of-sight analysis between points considering terrain elevation (SRTM data) Earth curvature and atmospheric refraction modeling Configurable search radius and antenna heights Support for different cellular radio types (2G, 3G, 4G, 5G) Detailed results including visibility status, distances, and azimuth angles Base Class: Visibility The Visibility class serves as the foundation for visibility analyses. Class Parameters Parameter Type Default Description points_of_interest PointOfInterestCollection Required Collection of points of interest cell_sites CellSiteCollection None Collection of cell sites srtm_data_handler SRTMDataHandler None Handler for SRTM elevation data search_radius int 35 Maximum distance (km) to search for visibility num_visible int 3 Number of visible sites/POIs to find poi_antenna_height float 15 Antenna height at POI locations (meters) allowed_radio_types list ['unknown', '2G', '3G', '4G', '5G'] Radio types to include earth_radius float 6371 Earth radius in kilometers refraction_coef float 0 Atmospheric refraction coefficient use_srtm bool True Whether to use SRTM elevation data logger Logger None Logger instance Class Attributes Attribute Type Description points_of_interest PointOfInterestCollection Collection of points of interest cell_sites CellSiteCollection Collection of cell sites srtm_data_handler SRTMDataHandler Handler for SRTM elevation data search_radius int Maximum search distance in meters analysis_param dict Parameters used for the analysis analysis_stats dict Statistics about the analysis run logger Logger Logger instance for the class Methods Method Return Type Description retrieve_srtm_data_files() None Downloads required SRTM elevation data get_antenna_height(point) float Gets antenna height for a point check_visibility(source, target, use_srtm, srtm_collection, search_radius) tuple Determines if target is visible from source considering terrain VisibilityCell: Cell Sites Visible from POIs Class Attributes Attribute Type Description analysis_results dict Dictionary storing analysis results per POI analysis_stats dict Statistics about the analysis run analysis_param dict Parameters used for the analysis Methods Method Return Type Description perform_analysis() None Executes visibility analysis, finding visible cell sites for each POI get_results_table() DataFrame Returns formatted results with detailed visibility information get_storage_table() DataFrame Returns raw analysis results as a DataFrame format_analysis_summary() str Returns a human-readable summary of analysis statistics retrieve_srtm_data_files() None Downloads required SRTM elevation data check_visibility() tuple Determines if target is visible from source considering terrain VisibilityPOI: Points of Interest Visible to Each Other Class Attributes Attribute Type Description analysis_results DataFrame DataFrame storing source-target pairs with visibility status Methods Method Return Type Description perform_analysis() None Computes visibility between all pairs of POIs get_results_table() DataFrame Returns a symmetrically formatted visibility graph retrieve_srtm_data_files() None Downloads required SRTM elevation data check_visibility() tuple Determines if target is visible from source considering terrain Example import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.entities.cellsite import CellSiteCollection from giga_inframapkit.handlers.srtmdatahandler import SRTMDataHandler from giga_inframapkit.visibility.visibility import VisibilityCell, VisibilityPOI # 1. Set up your data collections poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_collection = PointOfInterestCollection() poi_collection.load_from_records(poi_df.to_dict('records')) # PointOfInterestCollection: 104 entities cell_site_df = pd.read_csv(\"input/cell_sites.csv\") cell_site_collection = CellSiteCollection() cell_site_collection.load_from_records(cell_site_df.to_dict('records')) # CellSiteCollection: 34 entities # 2. Set up the elevation data handler, that downloads a raster file with elevation data into the data_dir srtm_data_handler = SRTMDataHandler(srtm_directory=f'/input/srtm1', logger=None) # 3. Perform POI to cell site visibility visibility_cellsites = VisibilityCell( points_of_interest=poi_collection, cell_sites=cell_site_collection, srtm_data_handler=srtm_data_handler, search_radius=35, num_visible=3, poi_antenna_height=25, allowed_radio_types=[\"4G\", \"5G\"], earth_radius=6371, refraction_coef=0, logger=None ) visibility_cellsites.perform_analysis() # INFO:visibility_STP:Locating SRTM data files... # INFO:visibility_STP:0 data file(s) to download. # INFO:visibility_STP:Downloading SRTM data files... # INFO:visibility_STP:Fetching from ITU public storage # INFO:visibility_STP:Filelist specified, downloading only selected files # INFO:visibility_STP:Downloaded completed # INFO:visibility_STP:Using 8 processes for parallel computation # INFO:visibility_STP:Processing 104 points of interest # INFO:visibility_STP:Checking cell site visibility: 0%| | 0/104 [00:00<?, ?it/s] # INFO:visibility_STP:Checking cell site visibility: 1%| | 1/104 [00:02<03:46, 2.20s/it] # INFO:visibility_STP:Checking cell site visibility: 18%|#8 | 19/104 [00:02<00:08, 9.85it/s] # INFO:visibility_STP:Checking cell site visibility: 36%|###5 | 37/104 [00:02<00:03, 19.56it/s] # INFO:visibility_STP:Checking cell site visibility: 100%|##########| 104/104 [00:02<00:00, 35.79it/s] # Visibility Analysis Summary: # Number of points of interest: 104 # Number of cell sites: 34 # Total visibility checks performed: 1803 # Average visibility checks per point of interest: 17.34 # Time taken for SRTM data download: 0.11 seconds # Time taken for analysis: 3.0 seconds # Total time elapsed: 3.11 seconds cellsites_results_table = visibility_cellsites.get_results_table() cellsites_results_table.head() # poi_id ict_id radio_type ground_distance antenna_los_distance azimuth_angle geometry is_visible num_visible order # 0 be6dc17a-57df-4709-bff1-18f433f7df71 4381fb37-07f8-465a-a654-6bc8df169be0 4G 269 269 211.41 LINESTRING (6.7332108 0.3300316, 6.73195 0.327... True 3 1 # 1 be6dc17a-57df-4709-bff1-18f433f7df71 7c4d5ac9-c381-485e-9c3f-99fbb062c837 4G 815 815 353.02 LINESTRING (6.7332108 0.3300316, 6.732319444 0... True 3 2 # 2 be6dc17a-57df-4709-bff1-18f433f7df71 cb6229b5-b934-4d5f-a7c1-39f33e1b1d6f 4G 881 881 77.87 LINESTRING (6.7332108 0.3300316, 6.740961111 0... True 3 3 # 3 7f4bf645-3665-4658-9913-edcb3fba3b2d 226b6f88-aac8-41af-8c88-6fd30b561afa 4G 683 683 21.55 LINESTRING (6.7235979 0.3330804, 6.725855556 0... True 3 1 # 4 7f4bf645-3665-4658-9913-edcb3fba3b2d b4fbe775-c7e9-4752-b21c-883b84ea08ad 4G 867 869 257.62 LINESTRING (6.7235979 0.3330804, 6.715980556 0... True 3 2 # 4. Perform POI to POI visibility visibility_pois = VisibilityPOI( points_of_interest=poi_collection, cell_sites=cell_site_collection, srtm_data_handler = srtm_data_handler, search_radius = 35, poi_antenna_height = 25, earth_radius = 6371, refraction_coef = 0, logger = None ) visibility_pois.perform_analysis() # INFO:visibility_STP:Locating SRTM data files... # INFO:visibility_STP:0 data file(s) to download. # INFO:visibility_STP:Downloading SRTM data files... # INFO:visibility_STP:Fetching from ITU public storage # INFO:visibility_STP:Filelist specified, downloading only selected files # INFO:visibility_STP:Downloaded completed # INFO:visibility_STP:Using 8 processes for parallel computation # INFO:visibility_STP:Processing 5356 POI pairs # INFO:visibility_STP:Checking POI-to-POI visibility: 0%| | 0/5356 [00:00<?, ?it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 0%| | 1/5356 [00:03<4:55:26, 3.31s/it] # INFO:visibility_STP:Checking POI-to-POI visibility: 6%|6 | 335/5356 [00:03<00:37, 135.50it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 19%|#8 | 1003/5356 [00:03<00:10, 417.91it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 50%|####9 | 2673/5356 [00:05<00:03, 842.69it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 56%|#####6 | 3007/5356 [00:05<00:02, 903.04it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 100%|##########| 5356/5356 [00:05<00:00, 999.95it/s] # INFO:visibility_STP:Analysis completed in 5.57 seconds pois_results_table = visibility_pois.get_results_table() pois_results_table.head() # poi_id visible_pois is_visible_pois # 0 09b90515-0ecc-4992-9d39-ae208e1c1fea [1d24a1c9-9d48-4ea0-9aa3-cfdb65d228a1] True # 1 0c16c2e8-db92-411b-a6f7-535fb1810e34 [967c9f47-5162-4f1b-aaa2-a7d77279d40c, 1e83e05... True # 2 1205e5ef-5d91-47b7-8fc0-11ef019263e5 [c77898fa-9377-4552-b2a1-c719f3257dbf, 76d2158... True # 3 1534adf8-b45c-443b-8e1d-87a504e6dc64 [82e467a9-50d8-407f-aa3a-58b68297b55b, 6dda061... True # 4 192c1704-9e7e-4b7a-8ba7-0eed5ae771ad [26ac2dc1-98e0-4ce7-8c1f-c6935b90ecc4, aeb454b... True","title":"Visibility"},{"location":"visibility/#visibility","text":"The Visibility module provides tools to analyze line-of-sight connectivity between different infrastructure components. It determines whether points of interest (POIs) have clear line-of-sight with cell sites or with other POIs, accounting for terrain elevation, Earth's curvature, and antenna heights. Line-of-sight is required to establish the feasibility of radio links between points of interest (POIs) and cell sites using visibility analysis. The analysis uses open topography data from the Shuttle Radar Topography Mission (SRTM), which provides 30-meter resolution elevation data. Figure: Visible cell site Figure: Obstructed cell site Key Features: Line-of-sight analysis between points considering terrain elevation (SRTM data) Earth curvature and atmospheric refraction modeling Configurable search radius and antenna heights Support for different cellular radio types (2G, 3G, 4G, 5G) Detailed results including visibility status, distances, and azimuth angles","title":"Visibility"},{"location":"visibility/#base-class-visibility","text":"The Visibility class serves as the foundation for visibility analyses.","title":"Base Class: Visibility"},{"location":"visibility/#class-parameters","text":"Parameter Type Default Description points_of_interest PointOfInterestCollection Required Collection of points of interest cell_sites CellSiteCollection None Collection of cell sites srtm_data_handler SRTMDataHandler None Handler for SRTM elevation data search_radius int 35 Maximum distance (km) to search for visibility num_visible int 3 Number of visible sites/POIs to find poi_antenna_height float 15 Antenna height at POI locations (meters) allowed_radio_types list ['unknown', '2G', '3G', '4G', '5G'] Radio types to include earth_radius float 6371 Earth radius in kilometers refraction_coef float 0 Atmospheric refraction coefficient use_srtm bool True Whether to use SRTM elevation data logger Logger None Logger instance","title":"Class Parameters"},{"location":"visibility/#class-attributes","text":"Attribute Type Description points_of_interest PointOfInterestCollection Collection of points of interest cell_sites CellSiteCollection Collection of cell sites srtm_data_handler SRTMDataHandler Handler for SRTM elevation data search_radius int Maximum search distance in meters analysis_param dict Parameters used for the analysis analysis_stats dict Statistics about the analysis run logger Logger Logger instance for the class","title":"Class Attributes"},{"location":"visibility/#methods","text":"Method Return Type Description retrieve_srtm_data_files() None Downloads required SRTM elevation data get_antenna_height(point) float Gets antenna height for a point check_visibility(source, target, use_srtm, srtm_collection, search_radius) tuple Determines if target is visible from source considering terrain","title":"Methods"},{"location":"visibility/#visibilitycell-cell-sites-visible-from-pois","text":"","title":"VisibilityCell: Cell Sites Visible from POIs"},{"location":"visibility/#class-attributes_1","text":"Attribute Type Description analysis_results dict Dictionary storing analysis results per POI analysis_stats dict Statistics about the analysis run analysis_param dict Parameters used for the analysis","title":"Class Attributes"},{"location":"visibility/#methods_1","text":"Method Return Type Description perform_analysis() None Executes visibility analysis, finding visible cell sites for each POI get_results_table() DataFrame Returns formatted results with detailed visibility information get_storage_table() DataFrame Returns raw analysis results as a DataFrame format_analysis_summary() str Returns a human-readable summary of analysis statistics retrieve_srtm_data_files() None Downloads required SRTM elevation data check_visibility() tuple Determines if target is visible from source considering terrain","title":"Methods"},{"location":"visibility/#visibilitypoi-points-of-interest-visible-to-each-other","text":"","title":"VisibilityPOI: Points of Interest Visible to Each Other"},{"location":"visibility/#class-attributes_2","text":"Attribute Type Description analysis_results DataFrame DataFrame storing source-target pairs with visibility status","title":"Class Attributes"},{"location":"visibility/#methods_2","text":"Method Return Type Description perform_analysis() None Computes visibility between all pairs of POIs get_results_table() DataFrame Returns a symmetrically formatted visibility graph retrieve_srtm_data_files() None Downloads required SRTM elevation data check_visibility() tuple Determines if target is visible from source considering terrain","title":"Methods"},{"location":"visibility/#example","text":"import pandas as pd from giga_inframapkit.entities.pointofinterest import PointOfInterestCollection from giga_inframapkit.entities.cellsite import CellSiteCollection from giga_inframapkit.handlers.srtmdatahandler import SRTMDataHandler from giga_inframapkit.visibility.visibility import VisibilityCell, VisibilityPOI # 1. Set up your data collections poi_df = pd.read_csv(\"input/points_of_interest.csv\") poi_collection = PointOfInterestCollection() poi_collection.load_from_records(poi_df.to_dict('records')) # PointOfInterestCollection: 104 entities cell_site_df = pd.read_csv(\"input/cell_sites.csv\") cell_site_collection = CellSiteCollection() cell_site_collection.load_from_records(cell_site_df.to_dict('records')) # CellSiteCollection: 34 entities # 2. Set up the elevation data handler, that downloads a raster file with elevation data into the data_dir srtm_data_handler = SRTMDataHandler(srtm_directory=f'/input/srtm1', logger=None) # 3. Perform POI to cell site visibility visibility_cellsites = VisibilityCell( points_of_interest=poi_collection, cell_sites=cell_site_collection, srtm_data_handler=srtm_data_handler, search_radius=35, num_visible=3, poi_antenna_height=25, allowed_radio_types=[\"4G\", \"5G\"], earth_radius=6371, refraction_coef=0, logger=None ) visibility_cellsites.perform_analysis() # INFO:visibility_STP:Locating SRTM data files... # INFO:visibility_STP:0 data file(s) to download. # INFO:visibility_STP:Downloading SRTM data files... # INFO:visibility_STP:Fetching from ITU public storage # INFO:visibility_STP:Filelist specified, downloading only selected files # INFO:visibility_STP:Downloaded completed # INFO:visibility_STP:Using 8 processes for parallel computation # INFO:visibility_STP:Processing 104 points of interest # INFO:visibility_STP:Checking cell site visibility: 0%| | 0/104 [00:00<?, ?it/s] # INFO:visibility_STP:Checking cell site visibility: 1%| | 1/104 [00:02<03:46, 2.20s/it] # INFO:visibility_STP:Checking cell site visibility: 18%|#8 | 19/104 [00:02<00:08, 9.85it/s] # INFO:visibility_STP:Checking cell site visibility: 36%|###5 | 37/104 [00:02<00:03, 19.56it/s] # INFO:visibility_STP:Checking cell site visibility: 100%|##########| 104/104 [00:02<00:00, 35.79it/s] # Visibility Analysis Summary: # Number of points of interest: 104 # Number of cell sites: 34 # Total visibility checks performed: 1803 # Average visibility checks per point of interest: 17.34 # Time taken for SRTM data download: 0.11 seconds # Time taken for analysis: 3.0 seconds # Total time elapsed: 3.11 seconds cellsites_results_table = visibility_cellsites.get_results_table() cellsites_results_table.head() # poi_id ict_id radio_type ground_distance antenna_los_distance azimuth_angle geometry is_visible num_visible order # 0 be6dc17a-57df-4709-bff1-18f433f7df71 4381fb37-07f8-465a-a654-6bc8df169be0 4G 269 269 211.41 LINESTRING (6.7332108 0.3300316, 6.73195 0.327... True 3 1 # 1 be6dc17a-57df-4709-bff1-18f433f7df71 7c4d5ac9-c381-485e-9c3f-99fbb062c837 4G 815 815 353.02 LINESTRING (6.7332108 0.3300316, 6.732319444 0... True 3 2 # 2 be6dc17a-57df-4709-bff1-18f433f7df71 cb6229b5-b934-4d5f-a7c1-39f33e1b1d6f 4G 881 881 77.87 LINESTRING (6.7332108 0.3300316, 6.740961111 0... True 3 3 # 3 7f4bf645-3665-4658-9913-edcb3fba3b2d 226b6f88-aac8-41af-8c88-6fd30b561afa 4G 683 683 21.55 LINESTRING (6.7235979 0.3330804, 6.725855556 0... True 3 1 # 4 7f4bf645-3665-4658-9913-edcb3fba3b2d b4fbe775-c7e9-4752-b21c-883b84ea08ad 4G 867 869 257.62 LINESTRING (6.7235979 0.3330804, 6.715980556 0... True 3 2 # 4. Perform POI to POI visibility visibility_pois = VisibilityPOI( points_of_interest=poi_collection, cell_sites=cell_site_collection, srtm_data_handler = srtm_data_handler, search_radius = 35, poi_antenna_height = 25, earth_radius = 6371, refraction_coef = 0, logger = None ) visibility_pois.perform_analysis() # INFO:visibility_STP:Locating SRTM data files... # INFO:visibility_STP:0 data file(s) to download. # INFO:visibility_STP:Downloading SRTM data files... # INFO:visibility_STP:Fetching from ITU public storage # INFO:visibility_STP:Filelist specified, downloading only selected files # INFO:visibility_STP:Downloaded completed # INFO:visibility_STP:Using 8 processes for parallel computation # INFO:visibility_STP:Processing 5356 POI pairs # INFO:visibility_STP:Checking POI-to-POI visibility: 0%| | 0/5356 [00:00<?, ?it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 0%| | 1/5356 [00:03<4:55:26, 3.31s/it] # INFO:visibility_STP:Checking POI-to-POI visibility: 6%|6 | 335/5356 [00:03<00:37, 135.50it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 19%|#8 | 1003/5356 [00:03<00:10, 417.91it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 50%|####9 | 2673/5356 [00:05<00:03, 842.69it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 56%|#####6 | 3007/5356 [00:05<00:02, 903.04it/s] # INFO:visibility_STP:Checking POI-to-POI visibility: 100%|##########| 5356/5356 [00:05<00:00, 999.95it/s] # INFO:visibility_STP:Analysis completed in 5.57 seconds pois_results_table = visibility_pois.get_results_table() pois_results_table.head() # poi_id visible_pois is_visible_pois # 0 09b90515-0ecc-4992-9d39-ae208e1c1fea [1d24a1c9-9d48-4ea0-9aa3-cfdb65d228a1] True # 1 0c16c2e8-db92-411b-a6f7-535fb1810e34 [967c9f47-5162-4f1b-aaa2-a7d77279d40c, 1e83e05... True # 2 1205e5ef-5d91-47b7-8fc0-11ef019263e5 [c77898fa-9377-4552-b2a1-c719f3257dbf, 76d2158... True # 3 1534adf8-b45c-443b-8e1d-87a504e6dc64 [82e467a9-50d8-407f-aa3a-58b68297b55b, 6dda061... True # 4 192c1704-9e7e-4b7a-8ba7-0eed5ae771ad [26ac2dc1-98e0-4ce7-8c1f-c6935b90ecc4, aeb454b... True","title":"Example"}]}